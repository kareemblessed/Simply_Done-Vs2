diff --git a/src/client/App.tsx b/src/client/App.tsx
index bcdbba9..f33eafd 100644
--- a/src/client/App.tsx
+++ b/src/client/App.tsx
@@ -1,17 +1,117 @@
 
 import React, { useEffect, useState, useMemo } from 'react';
-import { Task, Priority, TaskStats, SortOption } from '../shared/types/task.types';
+import { Task, Priority, SortOption, TaskObserver, TaskEvent, UpdateTaskDTO } from '../shared/types/task.types';
 import { getPriorityWeight } from '../shared/utils/helpers';
 import { apiService } from './services/apiService';
+import { taskService } from '../server/services/taskService';
 import { TaskForm } from './components/TaskForm';
 import { FilterBar } from './components/FilterBar';
 import { StatsCard } from './components/StatsCard';
 import { TaskList } from './components/TaskList';
 
+// --- Reducer Types & Logic (Exported for Testing) ---
+
+export interface TaskState {
+  tasks: Task[];
+  pendingActions: any[];
+  error: string | null;
+}
+
+export type OptimisticAction = 
+  | { type: 'ADD_TASK_OPTIMISTIC', payload: { tempId: string, task: Task } }
+  | { type: 'UPDATE_TASK_OPTIMISTIC', payload: { id: string, updates: Partial<Task>, original: Task, actionId: string } }
+  | { type: 'DELETE_TASK_OPTIMISTIC', payload: { id: string, original: Task, actionId: string } }
+  | { type: 'ROLLBACK_ACTION', payload: { actionId: string, error: string } }
+  | { type: 'COMMIT_ACTION', payload: { tempId: string, finalTask: Task, actionId: string } }
+  | { type: 'SET_TASKS', payload: Task[] }
+  | { type: 'SET_ERROR', payload: string };
+
+export const initialState: TaskState = {
+  tasks: [],
+  pendingActions: [],
+  error: null
+};
+
+export const taskReducer = (state: TaskState, action: OptimisticAction): TaskState => {
+  switch (action.type) {
+    case 'ADD_TASK_OPTIMISTIC':
+      return {
+        ...state,
+        tasks: [action.payload.task, ...state.tasks],
+        pendingActions: [...state.pendingActions, { 
+          id: action.payload.tempId, // Using tempId as actionId for create
+          type: 'CREATE', 
+          taskId: action.payload.tempId 
+        }]
+      };
+    case 'UPDATE_TASK_OPTIMISTIC':
+      return {
+        ...state,
+        tasks: state.tasks.map(t => t.id === action.payload.id ? { ...t, ...action.payload.updates } : t),
+        pendingActions: [...state.pendingActions, { 
+          id: action.payload.actionId, 
+          type: 'UPDATE', 
+          taskId: action.payload.id,
+          previousState: action.payload.original
+        }]
+      };
+    case 'DELETE_TASK_OPTIMISTIC':
+      return {
+        ...state,
+        tasks: state.tasks.filter(t => t.id !== action.payload.id),
+        pendingActions: [...state.pendingActions, { 
+          id: action.payload.actionId, 
+          type: 'DELETE', 
+          taskId: action.payload.id,
+          previousState: action.payload.original
+        }]
+      };
+    case 'ROLLBACK_ACTION': {
+      const actionId = action.payload.actionId;
+      const actionToRollback = state.pendingActions.find(a => a.id === actionId);
+      
+      if (!actionToRollback) {
+        return { ...state, error: action.payload.error };
+      }
+
+      let restoredTasks = [...state.tasks];
+      
+      if (actionToRollback.type === 'CREATE') {
+        restoredTasks = restoredTasks.filter(t => t.id !== actionToRollback.taskId);
+      } else if (actionToRollback.type === 'UPDATE') {
+        restoredTasks = restoredTasks.map(t => 
+          t.id === actionToRollback.taskId ? actionToRollback.previousState : t
+        );
+      } else if (actionToRollback.type === 'DELETE') {
+        restoredTasks = [...restoredTasks, actionToRollback.previousState];
+      }
+
+      return {
+        ...state,
+        tasks: restoredTasks,
+        pendingActions: state.pendingActions.filter(a => a.id !== actionId),
+        error: action.payload.error
+      };
+    }
+    case 'COMMIT_ACTION':
+      return {
+        ...state,
+        // For CREATE, we swap the temp ID with real ID. For others, likely no-op on tasks array unless data changed.
+        tasks: state.tasks.map(t => t.id === action.payload.tempId ? action.payload.finalTask : t),
+        pendingActions: state.pendingActions.filter(a => a.id !== action.payload.actionId)
+      };
+    case 'SET_TASKS':
+      return { ...state, tasks: action.payload, error: null };
+    case 'SET_ERROR':
+      return { ...state, error: action.payload };
+    default:
+      return state;
+  }
+};
+
 const App: React.FC = () => {
   // --- State ---
   const [tasks, setTasks] = useState<Task[]>([]);
-  const [stats, setStats] = useState<TaskStats | null>(null);
   const [loading, setLoading] = useState(true);
   const [error, setError] = useState<string | null>(null);
   
@@ -20,15 +120,17 @@ const App: React.FC = () => {
   const [sort, setSort] = useState<SortOption>(SortOption.NEWEST);
 
   // --- Actions ---
+  const loadTasks = () => {
+    // Direct read from service for instant updates via observer
+    const data = taskService.getAll();
+    setTasks([...data]); // Create new reference
+  };
+
   const refreshData = async () => {
     try {
       setLoading(true);
-      const [fetchedTasks, fetchedStats] = await Promise.all([
-        apiService.fetchTasks(),
-        apiService.getStats()
-      ]);
+      const fetchedTasks = await apiService.fetchTasks();
       setTasks(fetchedTasks);
-      setStats(fetchedStats);
       setError(null);
     } catch (err: any) {
       setError(err.message || 'Failed to load data');
@@ -38,48 +140,71 @@ const App: React.FC = () => {
   };
 
   useEffect(() => {
+    // Initial Load
     refreshData();
+
+    // Subscribe to Task Changes
+    const observer: TaskObserver = {
+      update: (event: TaskEvent) => {
+        // On any change, reload the local task list
+        // This provides "real-time" updates bypassing the apiService delay for the UI
+        loadTasks();
+      }
+    };
+
+    taskService.subscribe(observer);
+    return () => taskService.unsubscribe(observer);
   }, []);
 
-  const updateStats = async () => {
+  const handleAddTask = async (text: string, priority: Priority, desc?: string) => {
     try {
-      const newStats = await apiService.getStats();
-      setStats(newStats);
-    } catch (e) { console.error(e); }
+      // API call initiates the process. 
+      // The Service will notify observers (us) when the task is actually created in DB.
+      await apiService.createTask(text, priority, desc);
+    } catch (err: any) { alert(err.message); }
   };
 
-  const handleAddTask = async (text: string, priority: Priority, desc?: string) => {
+  const handleEditTask = async (id: string, updates: Partial<Task>) => {
     try {
-      const newTask = await apiService.createTask(text, priority, desc);
-      setTasks(prev => [newTask, ...prev]);
-      await updateStats();
+      // Convert Partial<Task> to UpdateTaskDTO to satisfy TS
+      const dto: UpdateTaskDTO = {
+        text: updates.text,
+        description: updates.description,
+        priority: updates.priority,
+        isCompleted: updates.isCompleted,
+        subtasks: updates.subtasks
+      };
+      
+      // Clean undefined values
+      Object.keys(dto).forEach(key => (dto as any)[key] === undefined && delete (dto as any)[key]);
+
+      await apiService.updateTask(id, dto);
     } catch (err: any) { alert(err.message); }
   };
 
   const handleToggleTask = async (id: string, currentStatus: boolean) => {
-    setTasks(prev => prev.map(t => t.id === id ? { ...t, isCompleted: !currentStatus } : t));
     try {
       await apiService.toggleTask(id, currentStatus);
-      await updateStats();
-    } catch (err: any) { refreshData(); alert(err.message); }
+    } catch (err: any) { alert(err.message); }
+  };
+
+  const handleToggleSubtask = async (taskId: string, subtaskId: string) => {
+     try {
+       await apiService.toggleSubtask(taskId, subtaskId);
+     } catch (err: any) { alert(err.message); }
   };
 
   const handleDeleteTask = async (id: string) => {
     if (!confirm('Delete this task?')) return;
-    const old = [...tasks];
-    setTasks(prev => prev.filter(t => t.id !== id));
     try {
       await apiService.deleteTask(id);
-      await updateStats();
-    } catch (err: any) { setTasks(old); alert(err.message); }
+    } catch (err: any) { alert(err.message); }
   };
 
   const handleClearCompleted = async () => {
     if (!confirm('Clear all completed tasks?')) return;
     try {
       await apiService.clearCompleted();
-      setTasks(prev => prev.filter(t => !t.isCompleted));
-      await updateStats();
     } catch (err: any) { alert(err.message); }
   };
 
@@ -115,8 +240,8 @@ const App: React.FC = () => {
           </p>
         </div>
 
-        {/* Stats */}
-        {!loading && !error && <StatsCard stats={stats} />}
+        {/* Stats - Self Managed via Observer */}
+        {!loading && !error && <StatsCard />}
 
         {/* Form */}
         <TaskForm onAdd={handleAddTask} />
@@ -129,7 +254,7 @@ const App: React.FC = () => {
             onFilterChange={setFilter}
             onSortChange={setSort}
             onClearCompleted={handleClearCompleted}
-            hasCompleted={tasks.some(t => t.isCompleted)}
+            // hasCompleted is now managed internally by FilterBar
           />
 
           {error && (
@@ -143,7 +268,9 @@ const App: React.FC = () => {
             tasks={processedTasks}
             loading={loading}
             onToggle={handleToggleTask}
+            onToggleSubtask={handleToggleSubtask}
             onDelete={handleDeleteTask}
+            onEdit={handleEditTask}
             emptyMessage={
               filter === 'ALL' ? "Your list is empty. Add a task above to get started!" 
               : filter === 'ACTIVE' ? "You're all caught up! Great job." 
@@ -154,7 +281,7 @@ const App: React.FC = () => {
 
         <div className="mt-12 text-center opacity-60">
            <p className="text-[10px] text-slate-500 font-bold tracking-[0.2em] uppercase">
-             v2.1 • LocalStorage Database • Secure
+             v2.2 • LocalStorage Database • Secure
            </p>
         </div>
       </div>
diff --git a/src/client/components/FilterBar.tsx b/src/client/components/FilterBar.tsx
index 8f938bc..b8484ac 100644
--- a/src/client/components/FilterBar.tsx
+++ b/src/client/components/FilterBar.tsx
@@ -1,6 +1,7 @@
 
-import React from 'react';
-import { SortOption } from '../../shared/types/task.types';
+import React, { useEffect, useState } from 'react';
+import { SortOption, TaskObserver, TaskEvent } from '../../shared/types/task.types';
+import { taskService } from '../../server/services/taskService';
 
 interface FilterBarProps {
   currentFilter: 'ALL' | 'ACTIVE' | 'COMPLETED';
@@ -8,7 +9,6 @@ interface FilterBarProps {
   onFilterChange: (f: 'ALL' | 'ACTIVE' | 'COMPLETED') => void;
   onSortChange: (s: SortOption) => void;
   onClearCompleted: () => void;
-  hasCompleted: boolean;
 }
 
 export const FilterBar: React.FC<FilterBarProps> = ({ 
@@ -16,9 +16,31 @@ export const FilterBar: React.FC<FilterBarProps> = ({
   currentSort, 
   onFilterChange, 
   onSortChange,
-  onClearCompleted,
-  hasCompleted
+  onClearCompleted
 }) => {
+  const [hasCompleted, setHasCompleted] = useState(false);
+
+  useEffect(() => {
+    const checkCompleted = () => {
+      const tasks = taskService.getAll();
+      setHasCompleted(tasks.some(t => t.isCompleted));
+    };
+
+    // Initial check
+    checkCompleted();
+
+    const observer: TaskObserver = {
+      update: (event: TaskEvent) => {
+        // Optimisation: We only care if completion status might have changed
+        // But for simplicity and robustness in this demo, we check on all mutations
+        checkCompleted();
+      }
+    };
+
+    taskService.subscribe(observer);
+    return () => taskService.unsubscribe(observer);
+  }, []);
+
   return (
     <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-6 pb-6 border-b border-slate-100">
       <div className="flex bg-slate-100/80 p-1 rounded-xl backdrop-blur-sm">
diff --git a/src/client/components/StatsCard.tsx b/src/client/components/StatsCard.tsx
index 2b022e2..c0f36ec 100644
--- a/src/client/components/StatsCard.tsx
+++ b/src/client/components/StatsCard.tsx
@@ -1,10 +1,7 @@
 
-import React from 'react';
-import { TaskStats } from '../../shared/types/task.types';
-
-interface StatsCardProps {
-  stats: TaskStats | null;
-}
+import React, { useEffect, useState } from 'react';
+import { TaskStats, TaskObserver, TaskEvent } from '../../shared/types/task.types';
+import { taskService } from '../../server/services/taskService';
 
 const StatItem = ({ label, value, colorClass }: { label: string, value: string | number, colorClass: string }) => (
   <div className="bg-white/80 backdrop-blur-sm p-4 rounded-2xl shadow-sm border border-white/50 transform hover:scale-105 transition-all duration-300">
@@ -13,7 +10,25 @@ const StatItem = ({ label, value, colorClass }: { label: string, value: string |
   </div>
 );
 
-export const StatsCard: React.FC<StatsCardProps> = ({ stats }) => {
+export const StatsCard: React.FC = () => {
+  const [stats, setStats] = useState<TaskStats | null>(null);
+
+  useEffect(() => {
+    // Initial fetch
+    setStats(taskService.getStats());
+
+    const observer: TaskObserver = {
+      update: (event: TaskEvent) => {
+        // Stats are relevant to almost all mutations
+        // 'UPDATE' might be relevant if completion changed
+        setStats(taskService.getStats());
+      }
+    };
+
+    taskService.subscribe(observer);
+    return () => taskService.unsubscribe(observer);
+  }, []);
+
   if (!stats) return null;
 
   return (
diff --git a/src/client/services/apiService.ts b/src/client/services/apiService.ts
index c53d3aa..90de9a2 100644
--- a/src/client/services/apiService.ts
+++ b/src/client/services/apiService.ts
@@ -6,6 +6,7 @@
 
 import { Task, CreateTaskDTO, UpdateTaskDTO, TaskStats, Priority } from '../../shared/types/task.types';
 import { TaskController } from '../../server/index';
+import { TaskValidator } from '../../server/validators/taskValidator';
 
 /**
  * Handles communication between Frontend components and the Backend Controller.
@@ -20,11 +21,22 @@ export const apiService = {
 
   async createTask(text: string, priority: Priority, description?: string): Promise<Task> {
     const payload: CreateTaskDTO = { text, priority, description };
+    
+    // Validate locally if possible, but controller also validates
+    const validationError = TaskValidator.validateCreate(payload);
+    if (validationError) throw new Error(validationError);
+
     const response = await TaskController.createTask(payload);
     if (!response.success || !response.data) throw new Error(response.error);
     return response.data;
   },
 
+  async updateTask(id: string, updates: UpdateTaskDTO): Promise<Task> {
+    const response = await TaskController.updateTask(id, updates);
+    if (!response.success || !response.data) throw new Error(response.error);
+    return response.data;
+  },
+
   async toggleTask(id: string, currentStatus: boolean): Promise<Task> {
     const payload: UpdateTaskDTO = { isCompleted: !currentStatus };
     const response = await TaskController.updateTask(id, payload);
@@ -32,6 +44,13 @@ export const apiService = {
     return response.data;
   },
 
+  async toggleSubtask(taskId: string, subtaskId: string): Promise<Task> {
+    // Ensure TaskController has this method
+    const response = await TaskController.toggleSubtask(taskId, subtaskId);
+    if (!response.success || !response.data) throw new Error(response.error);
+    return response.data;
+  },
+
   async deleteTask(id: string): Promise<void> {
     const response = await TaskController.deleteTask(id);
     if (!response.success) throw new Error(response.error);
diff --git a/src/server/controllers/taskController.ts b/src/server/controllers/taskController.ts
index 4028278..fa4956d 100644
--- a/src/server/controllers/taskController.ts
+++ b/src/server/controllers/taskController.ts
@@ -63,6 +63,17 @@ export const TaskController = {
     }
   },
 
+  async toggleSubtask(taskId: string, subtaskId: string): Promise<ApiResponse<Task>> {
+    await delay(150);
+    try {
+      const task = taskService.toggleSubtask(taskId, subtaskId);
+      if (!task) return this._response(false, undefined, 'Task or subtask not found', 404);
+      return this._response(true, task);
+    } catch (e) {
+      return this._response(false, undefined, 'Subtask toggle failed', 500);
+    }
+  },
+
   async deleteTask(id: string): Promise<ApiResponse<null>> {
     await delay(200);
     try {
diff --git a/src/server/db/jsonDatabase.ts b/src/server/db/jsonDatabase.ts
index 991a1a6..ae84460 100644
--- a/src/server/db/jsonDatabase.ts
+++ b/src/server/db/jsonDatabase.ts
@@ -8,10 +8,32 @@ import { Task, SystemLog } from '../../shared/types/task.types';
 import { DB_KEYS } from '../../shared/constants';
 
 class JsonDatabase {
+  // In-memory fallback for environments without localStorage (like Node.js tests)
+  private memoryStorage: Record<string, string> = {};
+
+  // Check if we are running in a browser environment
+  private get isBrowser(): boolean {
+    return typeof window !== 'undefined' && typeof window.localStorage !== 'undefined';
+  }
+
+  private getItem(key: string): string | null {
+    if (this.isBrowser) {
+      return window.localStorage.getItem(key);
+    }
+    return this.memoryStorage[key] || null;
+  }
+
+  private setItem(key: string, value: string): void {
+    if (this.isBrowser) {
+      window.localStorage.setItem(key, value);
+    } else {
+      this.memoryStorage[key] = value;
+    }
+  }
   
   readTasks(): Task[] {
     try {
-      const data = localStorage.getItem(DB_KEYS.TASKS);
+      const data = this.getItem(DB_KEYS.TASKS);
       return data ? JSON.parse(data) : [];
     } catch (e) {
       console.error("[DB] Read Error", e);
@@ -21,7 +43,7 @@ class JsonDatabase {
 
   writeTasks(tasks: Task[]): void {
     try {
-      localStorage.setItem(DB_KEYS.TASKS, JSON.stringify(tasks));
+      this.setItem(DB_KEYS.TASKS, JSON.stringify(tasks));
     } catch (e) {
       console.error("[DB] Write Error", e);
     }
@@ -33,15 +55,20 @@ class JsonDatabase {
       logs.push(log);
       // Limit logs to prevent localStorage quotas
       if (logs.length > 200) logs.shift();
-      localStorage.setItem(DB_KEYS.LOGS, JSON.stringify(logs));
+      this.setItem(DB_KEYS.LOGS, JSON.stringify(logs));
     } catch (e) {
       console.error("[DB] Log Error", e);
     }
   }
 
   readLogs(): SystemLog[] {
-    const data = localStorage.getItem(DB_KEYS.LOGS);
-    return data ? JSON.parse(data) : [];
+    try {
+      const data = this.getItem(DB_KEYS.LOGS);
+      return data ? JSON.parse(data) : [];
+    } catch (e) {
+       console.error("[DB] Log Read Error", e);
+       return [];
+    }
   }
 }
 
diff --git a/src/server/services/taskService.ts b/src/server/services/taskService.ts
index 16d21d4..5bb41a0 100644
--- a/src/server/services/taskService.ts
+++ b/src/server/services/taskService.ts
@@ -4,7 +4,7 @@
 // Path: src/server/services/taskService.ts
 // ============================================================================
 
-import { Task, CreateTaskDTO, UpdateTaskDTO, TaskStats, Priority, SystemLog } from '../../shared/types/task.types';
+import { Task, CreateTaskDTO, UpdateTaskDTO, TaskStats, Priority, SystemLog, TaskObserver, TaskEvent } from '../../shared/types/task.types';
 import { db } from '../db/jsonDatabase';
 
 // Internal Logger Service
@@ -27,7 +27,26 @@ function log(level: 'INFO' | 'WARN' | 'ERROR', message: string, context?: any) {
 }
 
 class TaskService {
+  private observers: TaskObserver[] = [];
+
+  // --- OBSERVER METHODS ---
+
+  subscribe(observer: TaskObserver): void {
+    if (!this.observers.includes(observer)) {
+      this.observers.push(observer);
+    }
+  }
+
+  unsubscribe(observer: TaskObserver): void {
+    this.observers = this.observers.filter(obs => obs !== observer);
+  }
+
+  private notify(event: TaskEvent): void {
+    this.observers.forEach(observer => observer.update(event));
+  }
   
+  // --- CRUD METHODS ---
+
   getAll(): Task[] {
     return db.readTasks();
   }
@@ -55,6 +74,7 @@ class TaskService {
       description: dto.description?.trim(),
       priority: dto.priority,
       isCompleted: false,
+      subtasks: [], // Initialize empty subtasks
       createdAt: Date.now(),
       updatedAt: Date.now(),
     };
@@ -63,6 +83,8 @@ class TaskService {
     db.writeTasks(tasks);
     Logger.info('Task created', { id: newTask.id });
     
+    this.notify({ type: 'CREATE', payload: newTask });
+    
     return newTask;
   }
 
@@ -93,9 +115,36 @@ class TaskService {
     db.writeTasks(tasks);
     Logger.info('Task updated', { id, updates: Object.keys(dto) });
     
+    this.notify({ type: 'UPDATE', payload: { taskId: id, updates: dto } });
+
     return updatedTask;
   }
 
+  toggleSubtask(taskId: string, subtaskId: string): Task | null {
+    const tasks = db.readTasks();
+    const taskIndex = tasks.findIndex(t => t.id === taskId);
+    
+    if (taskIndex === -1) return null;
+    
+    const task = tasks[taskIndex];
+    if (!task.subtasks) task.subtasks = []; // Defensive
+
+    const subtaskIndex = task.subtasks.findIndex(s => s.id === subtaskId);
+    if (subtaskIndex === -1) return null;
+
+    // Toggle status
+    task.subtasks[subtaskIndex].isCompleted = !task.subtasks[subtaskIndex].isCompleted;
+    task.updatedAt = Date.now();
+
+    tasks[taskIndex] = task;
+    db.writeTasks(tasks);
+    Logger.info('Subtask toggled', { taskId, subtaskId });
+
+    this.notify({ type: 'UPDATE', payload: { taskId, subtaskId } });
+
+    return task;
+  }
+
   delete(id: string): boolean {
     const tasks = db.readTasks();
     const filtered = tasks.filter(t => t.id !== id);
@@ -104,6 +153,9 @@ class TaskService {
 
     db.writeTasks(filtered);
     Logger.info('Task deleted', { id });
+    
+    this.notify({ type: 'DELETE', payload: { id } });
+    
     return true;
   }
 
@@ -115,6 +167,7 @@ class TaskService {
     if (countRemoved > 0) {
       db.writeTasks(activeTasks);
       Logger.info('Cleared completed tasks', { count: countRemoved });
+      this.notify({ type: 'CLEAR', payload: { count: countRemoved } });
     }
     
     return countRemoved;
diff --git a/src/server/validators/taskValidator.ts b/src/server/validators/taskValidator.ts
index fa39b18..e29f5a6 100644
--- a/src/server/validators/taskValidator.ts
+++ b/src/server/validators/taskValidator.ts
@@ -9,25 +9,46 @@ import { VALIDATION } from '../../shared/constants';
 
 export const TaskValidator = {
   
-  /**
-   * Validates the payload for creating a new task
-   */
-  validateCreate(dto: CreateTaskDTO): string | null {
-    if (!dto.text || dto.text.trim().length === 0) {
+  validateTitle(text: string): string | null {
+    if (!text || text.trim().length === 0) {
       return 'Task text is required';
     }
     
-    if (dto.text.length > VALIDATION.MAX_TITLE_LENGTH) {
+    if (text.length > VALIDATION.MAX_TITLE_LENGTH) {
       return `Task text cannot exceed ${VALIDATION.MAX_TITLE_LENGTH} characters`;
     }
-    
-    if (dto.description && dto.description.length > VALIDATION.MAX_DESC_LENGTH) {
+    return null;
+  },
+
+  validateDescription(description: string): string | null {
+    if (description && description.length > VALIDATION.MAX_DESC_LENGTH) {
       return `Description cannot exceed ${VALIDATION.MAX_DESC_LENGTH} characters`;
     }
-    
-    if (!Object.values(Priority).includes(dto.priority)) {
+    return null;
+  },
+
+  validatePriority(priority: Priority): string | null {
+    // Cast to string to allow checking against enum values even if passed as string (for testing)
+    if (!Object.values(Priority).includes(priority)) {
       return 'Invalid priority level provided';
     }
+    return null;
+  },
+
+  /**
+   * Validates the payload for creating a new task
+   */
+  validateCreate(dto: CreateTaskDTO): string | null {
+    const titleError = this.validateTitle(dto.text);
+    if (titleError) return titleError;
+    
+    if (dto.description) {
+      const descError = this.validateDescription(dto.description);
+      if (descError) return descError;
+    }
+    
+    const priorityError = this.validatePriority(dto.priority);
+    if (priorityError) return priorityError;
     
     return null;
   },
@@ -36,16 +57,23 @@ export const TaskValidator = {
    * Validates the payload for updating a task
    */
   validateUpdate(dto: UpdateTaskDTO): string | null {
-    if (dto.text !== undefined && dto.text.trim().length === 0) {
-      return 'Task text cannot be empty';
+    if (dto.text !== undefined) {
+      const titleError = this.validateTitle(dto.text);
+      if (titleError) {
+        // Normalize "required" error to "cannot be empty" for updates to match existing tests/specs
+        if (titleError === 'Task text is required') return 'Task text cannot be empty';
+        return titleError;
+      }
     }
     
-    if (dto.text && dto.text.length > VALIDATION.MAX_TITLE_LENGTH) {
-      return `Task text cannot exceed ${VALIDATION.MAX_TITLE_LENGTH} characters`;
+    if (dto.description) {
+      const descError = this.validateDescription(dto.description);
+      if (descError) return descError;
     }
 
-    if (dto.description && dto.description.length > VALIDATION.MAX_DESC_LENGTH) {
-      return `Description cannot exceed ${VALIDATION.MAX_DESC_LENGTH} characters`;
+    if (dto.priority) {
+      const priorityError = this.validatePriority(dto.priority);
+      if (priorityError) return priorityError;
     }
     
     return null;
diff --git a/src/shared/types/task.types.ts b/src/shared/types/task.types.ts
index 00b22be..03a1947 100644
--- a/src/shared/types/task.types.ts
+++ b/src/shared/types/task.types.ts
@@ -23,6 +23,15 @@ export enum SortOption {
   PRIORITY_ASC = 'PRIORITY_ASC',
 }
 
+/**
+ * Subtask item structure.
+ */
+export interface SubTask {
+  id: string;
+  text: string;
+  isCompleted: boolean;
+}
+
 /**
  * The core Task object.
  */
@@ -32,6 +41,7 @@ export interface Task {
   description?: string;
   isCompleted: boolean;
   priority: Priority;
+  subtasks: SubTask[];
   createdAt: number;
   updatedAt: number;
   completedAt?: number;
@@ -79,10 +89,11 @@ export interface UpdateTaskDTO {
   isCompleted?: boolean;
   priority?: Priority;
   description?: string;
+  subtasks?: SubTask[];
 }
 
 /**
- * Log entry for the backend logger.
+ * System Log entry structure used in server logs.
  */
 export interface SystemLog {
   id: string;
@@ -91,3 +102,16 @@ export interface SystemLog {
   timestamp: number;
   context?: any;
 }
+
+// --- OBSERVER PATTERN TYPES ---
+
+export type TaskEventType = 'CREATE' | 'UPDATE' | 'DELETE' | 'TOGGLE' | 'CLEAR';
+
+export interface TaskEvent {
+  type: TaskEventType;
+  payload?: any;
+}
+
+export interface TaskObserver {
+  update(event: TaskEvent): void;
+}
