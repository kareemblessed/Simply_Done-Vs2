diff --git a/src/client/App.tsx b/src/client/App.tsx
index bcdbba9..cef9c5b 100644
--- a/src/client/App.tsx
+++ b/src/client/App.tsx
@@ -1,5 +1,5 @@
 
-import React, { useEffect, useState, useMemo } from 'react';
+import React, { useEffect, useState, useMemo, useReducer } from 'react';
 import { Task, Priority, TaskStats, SortOption } from '../shared/types/task.types';
 import { getPriorityWeight } from '../shared/utils/helpers';
 import { apiService } from './services/apiService';
@@ -8,18 +8,154 @@ import { FilterBar } from './components/FilterBar';
 import { StatsCard } from './components/StatsCard';
 import { TaskList } from './components/TaskList';
 
+// --- OPTIMISTIC REDUCER LOGIC ---
+
+export type OptimisticAction = 
+  | { type: 'INIT_TASKS'; payload: Task[] }
+  | { type: 'ADD_TASK_OPTIMISTIC'; payload: { tempId: string; task: Task } }
+  | { type: 'UPDATE_TASK_OPTIMISTIC'; payload: { id: string; updates: Partial<Task>; original: Task; actionId: string } }
+  | { type: 'DELETE_TASK_OPTIMISTIC'; payload: { id: string; original: Task; actionId: string } }
+  | { type: 'COMMIT_ACTION'; payload: { tempId?: string; finalTask?: Task; actionId: string } }
+  | { type: 'ROLLBACK_ACTION'; payload: { actionId: string; error: string } };
+
+export interface PendingAction {
+  id: string; // Unique ID for the action
+  type: 'CREATE' | 'UPDATE' | 'DELETE';
+  taskId: string;
+  previousState?: Task; // Snapshot for rollback
+}
+
+export interface TaskState {
+  tasks: Task[];
+  pendingActions: PendingAction[];
+  error: string | null;
+}
+
+export const initialState: TaskState = {
+  tasks: [],
+  pendingActions: [],
+  error: null,
+};
+
+export function taskReducer(state: TaskState, action: OptimisticAction): TaskState {
+  switch (action.type) {
+    case 'INIT_TASKS':
+      return {
+        ...state,
+        tasks: action.payload,
+        pendingActions: [], 
+        error: null 
+      };
+
+    case 'ADD_TASK_OPTIMISTIC': {
+      const { tempId, task } = action.payload;
+      return {
+        ...state,
+        tasks: [task, ...state.tasks],
+        pendingActions: [...state.pendingActions, {
+          id: tempId,
+          type: 'CREATE',
+          taskId: tempId
+        }],
+        error: null
+      };
+    }
+
+    case 'UPDATE_TASK_OPTIMISTIC': {
+      const { id, updates, original, actionId } = action.payload;
+      return {
+        ...state,
+        tasks: state.tasks.map(t => t.id === id ? { ...t, ...updates } : t),
+        pendingActions: [...state.pendingActions, {
+          id: actionId,
+          type: 'UPDATE',
+          taskId: id,
+          previousState: original
+        }],
+        error: null
+      };
+    }
+
+    case 'DELETE_TASK_OPTIMISTIC': {
+      const { id, original, actionId } = action.payload;
+      return {
+        ...state,
+        tasks: state.tasks.filter(t => t.id !== id),
+        pendingActions: [...state.pendingActions, {
+          id: actionId,
+          type: 'DELETE',
+          taskId: id,
+          previousState: original
+        }],
+        error: null
+      };
+    }
+
+    case 'COMMIT_ACTION': {
+      const { tempId, finalTask, actionId } = action.payload;
+      
+      let newTasks = [...state.tasks];
+      
+      if (tempId && finalTask) {
+        newTasks = newTasks.map(t => t.id === tempId ? finalTask : t);
+      } 
+      else if (finalTask) {
+        newTasks = newTasks.map(t => t.id === finalTask.id ? finalTask : t);
+      }
+
+      return {
+        ...state,
+        tasks: newTasks,
+        pendingActions: state.pendingActions.filter(a => 
+          (tempId ? a.id !== tempId : a.id !== actionId)
+        )
+      };
+    }
+
+    case 'ROLLBACK_ACTION': {
+      const { actionId, error } = action.payload;
+      const pendingAction = state.pendingActions.find(a => a.id === actionId);
+      
+      if (!pendingAction) return { ...state, error: `Rollback failed: ${error}` };
+
+      let restoredTasks = [...state.tasks];
+
+      if (pendingAction.type === 'CREATE') {
+        restoredTasks = restoredTasks.filter(t => t.id !== pendingAction.taskId);
+      } else if (pendingAction.type === 'DELETE') {
+        if (pendingAction.previousState) {
+          restoredTasks = [...restoredTasks, pendingAction.previousState];
+          restoredTasks.sort((a, b) => b.createdAt - a.createdAt);
+        }
+      } else if (pendingAction.type === 'UPDATE') {
+        if (pendingAction.previousState) {
+          restoredTasks = restoredTasks.map(t => 
+            t.id === pendingAction.taskId ? pendingAction.previousState! : t
+          );
+        }
+      }
+
+      return {
+        ...state,
+        tasks: restoredTasks,
+        pendingActions: state.pendingActions.filter(a => a.id !== actionId),
+        error 
+      };
+    }
+
+    default:
+      return state;
+  }
+}
+
 const App: React.FC = () => {
-  // --- State ---
-  const [tasks, setTasks] = useState<Task[]>([]);
+  const [state, dispatch] = useReducer(taskReducer, initialState);
   const [stats, setStats] = useState<TaskStats | null>(null);
   const [loading, setLoading] = useState(true);
-  const [error, setError] = useState<string | null>(null);
   
-  // UI State
   const [filter, setFilter] = useState<'ALL' | 'ACTIVE' | 'COMPLETED'>('ALL');
   const [sort, setSort] = useState<SortOption>(SortOption.NEWEST);
 
-  // --- Actions ---
   const refreshData = async () => {
     try {
       setLoading(true);
@@ -27,11 +163,10 @@ const App: React.FC = () => {
         apiService.fetchTasks(),
         apiService.getStats()
       ]);
-      setTasks(fetchedTasks);
+      dispatch({ type: 'INIT_TASKS', payload: fetchedTasks });
       setStats(fetchedStats);
-      setError(null);
     } catch (err: any) {
-      setError(err.message || 'Failed to load data');
+      console.error(err);
     } finally {
       setLoading(false);
     }
@@ -49,43 +184,108 @@ const App: React.FC = () => {
   };
 
   const handleAddTask = async (text: string, priority: Priority, desc?: string) => {
+    const tempId = crypto.randomUUID();
+    const optimisticTask: Task = {
+      id: tempId,
+      text,
+      priority,
+      description: desc,
+      isCompleted: false,
+      subtasks: [],
+      createdAt: Date.now(),
+      updatedAt: Date.now()
+    };
+
+    dispatch({ type: 'ADD_TASK_OPTIMISTIC', payload: { tempId, task: optimisticTask } });
+
     try {
-      const newTask = await apiService.createTask(text, priority, desc);
-      setTasks(prev => [newTask, ...prev]);
+      const realTask = await apiService.createTask(text, priority, desc);
+      dispatch({ type: 'COMMIT_ACTION', payload: { tempId, finalTask: realTask, actionId: tempId } });
       await updateStats();
-    } catch (err: any) { alert(err.message); }
+    } catch (err: any) {
+      // Alert specifically for non-validation errors (validation handled in Form)
+      // or just fallback alert
+      dispatch({ type: 'ROLLBACK_ACTION', payload: { actionId: tempId, error: err.message } });
+    }
+  };
+
+  const handleEditTask = async (id: string, updates: Partial<Task>) => {
+    const original = state.tasks.find(t => t.id === id);
+    if (!original) return;
+
+    const actionId = crypto.randomUUID();
+    dispatch({ type: 'UPDATE_TASK_OPTIMISTIC', payload: { id, updates, original, actionId } });
+
+    try {
+      const updated = await apiService.updateTask(id, updates);
+      dispatch({ type: 'COMMIT_ACTION', payload: { finalTask: updated, actionId } });
+      await updateStats();
+    } catch (err: any) {
+      dispatch({ type: 'ROLLBACK_ACTION', payload: { actionId, error: err.message } });
+    }
   };
 
   const handleToggleTask = async (id: string, currentStatus: boolean) => {
-    setTasks(prev => prev.map(t => t.id === id ? { ...t, isCompleted: !currentStatus } : t));
+    const original = state.tasks.find(t => t.id === id);
+    if (!original) return;
+
+    const actionId = crypto.randomUUID();
+    dispatch({ type: 'UPDATE_TASK_OPTIMISTIC', payload: { id, updates: { isCompleted: !currentStatus }, original, actionId } });
+
     try {
-      await apiService.toggleTask(id, currentStatus);
+      const updated = await apiService.toggleTask(id, currentStatus);
+      dispatch({ type: 'COMMIT_ACTION', payload: { finalTask: updated, actionId } });
       await updateStats();
-    } catch (err: any) { refreshData(); alert(err.message); }
+    } catch (err: any) {
+      dispatch({ type: 'ROLLBACK_ACTION', payload: { actionId, error: err.message } });
+    }
+  };
+
+  const handleToggleSubtask = async (taskId: string, subtaskId: string) => {
+     const original = state.tasks.find(t => t.id === taskId);
+     if (!original) return;
+     
+     const newSubtasks = original.subtasks.map(s => s.id === subtaskId ? { ...s, isCompleted: !s.isCompleted } : s);
+     
+     const actionId = crypto.randomUUID();
+     dispatch({ type: 'UPDATE_TASK_OPTIMISTIC', payload: { id: taskId, updates: { subtasks: newSubtasks }, original, actionId } });
+
+     try {
+       const updated = await apiService.toggleSubtask(taskId, subtaskId);
+       dispatch({ type: 'COMMIT_ACTION', payload: { finalTask: updated, actionId } });
+     } catch (err: any) {
+       dispatch({ type: 'ROLLBACK_ACTION', payload: { actionId, error: err.message } });
+     }
   };
 
   const handleDeleteTask = async (id: string) => {
     if (!confirm('Delete this task?')) return;
-    const old = [...tasks];
-    setTasks(prev => prev.filter(t => t.id !== id));
+    
+    const original = state.tasks.find(t => t.id === id);
+    if (!original) return;
+
+    const actionId = crypto.randomUUID();
+    dispatch({ type: 'DELETE_TASK_OPTIMISTIC', payload: { id, original, actionId } });
+
     try {
       await apiService.deleteTask(id);
+      dispatch({ type: 'COMMIT_ACTION', payload: { actionId } });
       await updateStats();
-    } catch (err: any) { setTasks(old); alert(err.message); }
+    } catch (err: any) {
+      dispatch({ type: 'ROLLBACK_ACTION', payload: { actionId, error: err.message } });
+    }
   };
 
   const handleClearCompleted = async () => {
     if (!confirm('Clear all completed tasks?')) return;
     try {
       await apiService.clearCompleted();
-      setTasks(prev => prev.filter(t => !t.isCompleted));
-      await updateStats();
+      refreshData();
     } catch (err: any) { alert(err.message); }
   };
 
-  // --- Logic ---
   const processedTasks = useMemo(() => {
-    let result = [...tasks];
+    let result = [...state.tasks];
     if (filter === 'ACTIVE') result = result.filter(t => !t.isCompleted);
     else if (filter === 'COMPLETED') result = result.filter(t => t.isCompleted);
 
@@ -99,13 +299,12 @@ const App: React.FC = () => {
       }
     });
     return result;
-  }, [tasks, filter, sort]);
+  }, [state.tasks, filter, sort]);
 
   return (
     <div className="min-h-screen py-12 px-4 sm:px-6 lg:px-8 font-sans text-slate-900 relative">
       <div className="max-w-3xl mx-auto relative z-10">
         
-        {/* Header */}
         <div className="mb-12 text-center">
           <h1 className="text-6xl font-black tracking-tighter text-slate-800 mb-3 drop-shadow-sm">
             Simply<span className="text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600">Done</span>.
@@ -115,13 +314,10 @@ const App: React.FC = () => {
           </p>
         </div>
 
-        {/* Stats */}
-        {!loading && !error && <StatsCard stats={stats} />}
+        {!loading && !state.error && <StatsCard stats={stats} />}
 
-        {/* Form */}
         <TaskForm onAdd={handleAddTask} />
 
-        {/* Main List Area */}
         <div className="bg-white/60 backdrop-blur-2xl rounded-[2.5rem] p-8 shadow-2xl shadow-indigo-100/50 border border-white">
           <FilterBar 
             currentFilter={filter}
@@ -129,13 +325,13 @@ const App: React.FC = () => {
             onFilterChange={setFilter}
             onSortChange={setSort}
             onClearCompleted={handleClearCompleted}
-            hasCompleted={tasks.some(t => t.isCompleted)}
+            hasCompleted={state.tasks.some(t => t.isCompleted)}
           />
 
-          {error && (
-            <div className="mb-6 p-4 bg-red-50 text-red-700 rounded-2xl border border-red-100 flex items-center gap-3">
-              <span className="font-bold">Error:</span> {error}
-              <button onClick={refreshData} className="ml-auto underline hover:text-red-900 font-medium">Retry</button>
+          {state.error && (
+            <div className="mb-6 p-4 bg-red-50 text-red-700 rounded-2xl border border-red-100 flex items-center gap-3 animate-pulse">
+              <span className="font-bold">Sync Error:</span> {state.error}
+              <button onClick={() => dispatch({ type: 'INIT_TASKS', payload: state.tasks })} className="ml-auto underline hover:text-red-900 font-medium">Dismiss</button>
             </div>
           )}
 
@@ -143,7 +339,9 @@ const App: React.FC = () => {
             tasks={processedTasks}
             loading={loading}
             onToggle={handleToggleTask}
+            onToggleSubtask={handleToggleSubtask}
             onDelete={handleDeleteTask}
+            onEdit={handleEditTask}
             emptyMessage={
               filter === 'ALL' ? "Your list is empty. Add a task above to get started!" 
               : filter === 'ACTIVE' ? "You're all caught up! Great job." 
@@ -154,7 +352,7 @@ const App: React.FC = () => {
 
         <div className="mt-12 text-center opacity-60">
            <p className="text-[10px] text-slate-500 font-bold tracking-[0.2em] uppercase">
-             v2.1 • LocalStorage Database • Secure
+             v2.2 • LocalStorage Database • Secure
            </p>
         </div>
       </div>
diff --git a/src/client/components/TaskForm.tsx b/src/client/components/TaskForm.tsx
index d873564..7ee0a79 100644
--- a/src/client/components/TaskForm.tsx
+++ b/src/client/components/TaskForm.tsx
@@ -1,34 +1,105 @@
 
 import React, { useState } from 'react';
 import { Priority } from '../../shared/types/task.types';
+import { TaskValidator } from '../../server/validators/taskValidator';
 
 interface TaskFormProps {
   onAdd: (text: string, priority: Priority, desc?: string) => Promise<void>;
 }
 
+export interface FormState {
+  text: string;
+  description: string;
+  priority: Priority;
+  errors: {
+    text?: string;
+    description?: string;
+  };
+  touched: {
+    text?: boolean;
+    description?: boolean;
+  };
+}
+
 export const TaskForm: React.FC<TaskFormProps> = ({ onAdd }) => {
-  const [text, setText] = useState('');
-  const [description, setDescription] = useState('');
-  const [priority, setPriority] = useState<Priority>(Priority.MEDIUM);
+  const [form, setForm] = useState<FormState>({
+    text: '',
+    description: '',
+    priority: Priority.MEDIUM,
+    errors: {},
+    touched: {}
+  });
+
   const [isExpanded, setIsExpanded] = useState(false);
   const [isSubmitting, setIsSubmitting] = useState(false);
 
+  const validateField = (field: 'text' | 'description', value: string) => {
+    let error: string | null = null;
+    if (field === 'text') error = TaskValidator.validateTitle(value);
+    if (field === 'description') error = TaskValidator.validateDescription(value);
+    
+    setForm(prev => ({
+      ...prev,
+      errors: { ...prev.errors, [field]: error || undefined }
+    }));
+    return error;
+  };
+
+  const handleBlur = (field: 'text' | 'description') => {
+    setForm(prev => ({
+      ...prev,
+      touched: { ...prev.touched, [field]: true }
+    }));
+    validateField(field, field === 'text' ? form.text : form.description);
+  };
+
+  const handleChange = (field: 'text' | 'description', value: string) => {
+    setForm(prev => ({
+      ...prev,
+      [field]: value
+    }));
+    // Real-time validation
+    validateField(field, value);
+  };
+
+  const setPriority = (priority: Priority) => {
+    setForm(prev => ({ ...prev, priority }));
+  };
+
   const handleSubmit = async (e: React.FormEvent) => {
     e.preventDefault();
-    if (!text.trim()) return;
+    
+    // Final Validation
+    const textError = validateField('text', form.text);
+    const descError = validateField('description', form.description);
+
+    if (textError || descError) {
+       setForm(prev => ({
+         ...prev,
+         touched: { text: true, description: true }
+       }));
+       return;
+    }
 
     setIsSubmitting(true);
     try {
-      await onAdd(text, priority, description);
-      setText('');
-      setDescription('');
-      setPriority(Priority.MEDIUM);
+      await onAdd(form.text, form.priority, form.description);
+      // Reset form
+      setForm({
+        text: '',
+        description: '',
+        priority: Priority.MEDIUM,
+        errors: {},
+        touched: {}
+      });
       setIsExpanded(false);
     } finally {
       setIsSubmitting(false);
     }
   };
 
+  const hasErrors = !!form.errors.text || !!form.errors.description;
+
   return (
     <form onSubmit={handleSubmit} className="mb-10 bg-white p-2 rounded-3xl shadow-xl shadow-indigo-100/50 border border-indigo-50 relative z-10">
       <div className="flex flex-col gap-2">
@@ -36,27 +107,47 @@ export const TaskForm: React.FC<TaskFormProps> = ({ onAdd }) => {
         <div className="relative group">
           <input
             type="text"
-            value={text}
+            value={form.text}
             onFocus={() => setIsExpanded(true)}
-            onChange={(e) => setText(e.target.value)}
+            onBlur={() => handleBlur('text')}
+            onChange={(e) => handleChange('text', e.target.value)}
             placeholder="What's your focus today?"
-            className="w-full pl-6 pr-4 py-4 bg-transparent text-lg text-slate-800 placeholder:text-slate-400 focus:outline-none rounded-2xl transition-colors"
+            className={`w-full pl-6 pr-4 py-4 bg-transparent text-lg text-slate-800 placeholder:text-slate-400 focus:outline-none rounded-2xl transition-colors ${
+              form.touched.text && form.errors.text ? 'bg-red-50 text-red-900 placeholder:text-red-300' : ''
+            }`}
           />
-          <div className="absolute bottom-2 left-6 right-6 h-px bg-slate-100 group-focus-within:bg-indigo-100 transition-colors" />
+          <div className={`absolute bottom-2 left-6 right-6 h-px transition-colors ${
+             form.touched.text && form.errors.text ? 'bg-red-200' : 'bg-slate-100 group-focus-within:bg-indigo-100'
+          }`} />
+          
+          {/* Inline Error for Text */}
+          {form.touched.text && form.errors.text && (
+            <div className="absolute right-4 top-1/2 -translate-y-1/2 text-[10px] font-bold text-red-500 bg-white px-2 py-1 rounded-full shadow-sm border border-red-100 animate-pulse">
+              {form.errors.text}
+            </div>
+          )}
         </div>
 
         {/* Expanded Options */}
         <div className={`overflow-hidden transition-all duration-500 ease-in-out px-6 ${
-          isExpanded ? 'max-h-56 opacity-100 pb-4' : 'max-h-0 opacity-0 pb-0'
+          isExpanded || hasErrors ? 'max-h-64 opacity-100 pb-4' : 'max-h-0 opacity-0 pb-0'
         }`}>
           <div className="space-y-5 pt-2">
-            <input
-              type="text"
-              value={description}
-              onChange={(e) => setDescription(e.target.value)}
-              placeholder="Add details, context, or notes (optional)..."
-              className="w-full text-sm text-slate-600 placeholder:text-slate-400 focus:outline-none bg-slate-50 p-3 rounded-xl"
-            />
+            <div>
+              <input
+                type="text"
+                value={form.description}
+                onBlur={() => handleBlur('description')}
+                onChange={(e) => handleChange('description', e.target.value)}
+                placeholder="Add details, context, or notes (optional)..."
+                className={`w-full text-sm text-slate-600 placeholder:text-slate-400 focus:outline-none bg-slate-50 p-3 rounded-xl border ${
+                  form.touched.description && form.errors.description ? 'border-red-200 bg-red-50' : 'border-transparent'
+                }`}
+              />
+              {form.touched.description && form.errors.description && (
+                <p className="text-[10px] text-red-500 mt-1 ml-2 font-medium">{form.errors.description}</p>
+              )}
+            </div>
             
             <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
               <div className="flex gap-2 p-1 bg-slate-100 rounded-xl">
@@ -66,7 +157,7 @@ export const TaskForm: React.FC<TaskFormProps> = ({ onAdd }) => {
                     type="button"
                     onClick={() => setPriority(p)}
                     className={`px-4 py-2 rounded-lg text-xs font-bold uppercase tracking-wider transition-all duration-200 ${
-                      priority === p
+                      form.priority === p
                         ? 'bg-white text-indigo-600 shadow-md transform scale-105'
                         : 'text-slate-400 hover:text-slate-600'
                     }`}
@@ -78,10 +169,10 @@ export const TaskForm: React.FC<TaskFormProps> = ({ onAdd }) => {
 
               <button
                 type="submit"
-                disabled={!text.trim() || isSubmitting}
+                disabled={!form.text.trim() || isSubmitting || hasErrors}
                 className={`w-full sm:w-auto px-8 py-3 rounded-xl text-sm font-bold tracking-wide text-white shadow-lg transition-all duration-300 transform hover:-translate-y-1 ${
-                  !text.trim() || isSubmitting
-                    ? 'bg-slate-300 cursor-not-allowed shadow-none'
+                  !form.text.trim() || isSubmitting || hasErrors
+                    ? 'bg-slate-300 cursor-not-allowed shadow-none hover:translate-y-0'
                     : 'bg-gradient-to-r from-indigo-600 to-violet-600 hover:shadow-indigo-300 hover:from-indigo-500 hover:to-violet-500'
                 }`}
               >
diff --git a/src/client/services/apiService.ts b/src/client/services/apiService.ts
index c53d3aa..3daf22f 100644
--- a/src/client/services/apiService.ts
+++ b/src/client/services/apiService.ts
@@ -6,6 +6,7 @@
 
 import { Task, CreateTaskDTO, UpdateTaskDTO, TaskStats, Priority } from '../../shared/types/task.types';
 import { TaskController } from '../../server/index';
+import { TaskValidator } from '../../server/validators/taskValidator';
 
 /**
  * Handles communication between Frontend components and the Backend Controller.
@@ -20,21 +21,38 @@ export const apiService = {
 
   async createTask(text: string, priority: Priority, description?: string): Promise<Task> {
     const payload: CreateTaskDTO = { text, priority, description };
+    
+    // Validate before sending to backend
+    const validationError = TaskValidator.validateCreate(payload);
+    if (validationError) throw new Error(validationError);
+
     const response = await TaskController.createTask(payload);
-    if (!response.success || !response.data) throw new Error(response.error);
+    if (!response.success || !response.data) throw new Error(response.error || 'Failed to create task');
+    return response.data;
+  },
+
+  async updateTask(id: string, updates: UpdateTaskDTO): Promise<Task> {
+    const response = await TaskController.updateTask(id, updates);
+    if (!response.success || !response.data) throw new Error(response.error || 'Failed to update task');
     return response.data;
   },
 
   async toggleTask(id: string, currentStatus: boolean): Promise<Task> {
     const payload: UpdateTaskDTO = { isCompleted: !currentStatus };
     const response = await TaskController.updateTask(id, payload);
-    if (!response.success || !response.data) throw new Error(response.error);
+    if (!response.success || !response.data) throw new Error(response.error || 'Failed to toggle task');
+    return response.data;
+  },
+
+  async toggleSubtask(taskId: string, subtaskId: string): Promise<Task> {
+    const response = await TaskController.toggleSubtask(taskId, subtaskId);
+    if (!response.success || !response.data) throw new Error(response.error || 'Failed to toggle subtask');
     return response.data;
   },
 
   async deleteTask(id: string): Promise<void> {
     const response = await TaskController.deleteTask(id);
-    if (!response.success) throw new Error(response.error);
+    if (!response.success) throw new Error(response.error || 'Failed to delete task');
   },
 
   async clearCompleted(): Promise<number> {
diff --git a/src/server/controllers/taskController.ts b/src/server/controllers/taskController.ts
index 4028278..fa4956d 100644
--- a/src/server/controllers/taskController.ts
+++ b/src/server/controllers/taskController.ts
@@ -63,6 +63,17 @@ export const TaskController = {
     }
   },
 
+  async toggleSubtask(taskId: string, subtaskId: string): Promise<ApiResponse<Task>> {
+    await delay(150);
+    try {
+      const task = taskService.toggleSubtask(taskId, subtaskId);
+      if (!task) return this._response(false, undefined, 'Task or subtask not found', 404);
+      return this._response(true, task);
+    } catch (e) {
+      return this._response(false, undefined, 'Subtask toggle failed', 500);
+    }
+  },
+
   async deleteTask(id: string): Promise<ApiResponse<null>> {
     await delay(200);
     try {
diff --git a/src/server/services/taskService.ts b/src/server/services/taskService.ts
index 16d21d4..7470181 100644
--- a/src/server/services/taskService.ts
+++ b/src/server/services/taskService.ts
@@ -26,7 +26,7 @@ function log(level: 'INFO' | 'WARN' | 'ERROR', message: string, context?: any) {
   if (level === 'ERROR') console.error(`[SERVER] ${message}`, context);
 }
 
-class TaskService {
+export class TaskService {
   
   getAll(): Task[] {
     return db.readTasks();
@@ -55,6 +55,7 @@ class TaskService {
       description: dto.description?.trim(),
       priority: dto.priority,
       isCompleted: false,
+      subtasks: [], // Initialize empty subtasks
       createdAt: Date.now(),
       updatedAt: Date.now(),
     };
@@ -96,6 +97,29 @@ class TaskService {
     return updatedTask;
   }
 
+  toggleSubtask(taskId: string, subtaskId: string): Task | null {
+    const tasks = db.readTasks();
+    const taskIndex = tasks.findIndex(t => t.id === taskId);
+    
+    if (taskIndex === -1) return null;
+    
+    const task = tasks[taskIndex];
+    if (!task.subtasks) task.subtasks = []; // Defensive
+
+    const subtaskIndex = task.subtasks.findIndex(s => s.id === subtaskId);
+    if (subtaskIndex === -1) return null;
+
+    // Toggle status
+    task.subtasks[subtaskIndex].isCompleted = !task.subtasks[subtaskIndex].isCompleted;
+    task.updatedAt = Date.now();
+
+    tasks[taskIndex] = task;
+    db.writeTasks(tasks);
+    Logger.info('Subtask toggled', { taskId, subtaskId });
+
+    return task;
+  }
+
   delete(id: string): boolean {
     const tasks = db.readTasks();
     const filtered = tasks.filter(t => t.id !== id);
diff --git a/src/server/validators/taskValidator.ts b/src/server/validators/taskValidator.ts
index fa39b18..fb4fefa 100644
--- a/src/server/validators/taskValidator.ts
+++ b/src/server/validators/taskValidator.ts
@@ -10,42 +10,59 @@ import { VALIDATION } from '../../shared/constants';
 export const TaskValidator = {
   
   /**
-   * Validates the payload for creating a new task
+   * Validate task title
    */
-  validateCreate(dto: CreateTaskDTO): string | null {
-    if (!dto.text || dto.text.trim().length === 0) {
+  validateTitle(text: string): string | null {
+    if (!text || text.trim().length === 0) {
       return 'Task text is required';
     }
-    
-    if (dto.text.length > VALIDATION.MAX_TITLE_LENGTH) {
+    if (text.length > VALIDATION.MAX_TITLE_LENGTH) {
       return `Task text cannot exceed ${VALIDATION.MAX_TITLE_LENGTH} characters`;
     }
-    
-    if (dto.description && dto.description.length > VALIDATION.MAX_DESC_LENGTH) {
+    return null;
+  },
+
+  /**
+   * Validate task description
+   */
+  validateDescription(description?: string): string | null {
+    if (description && description.length > VALIDATION.MAX_DESC_LENGTH) {
       return `Description cannot exceed ${VALIDATION.MAX_DESC_LENGTH} characters`;
     }
-    
-    if (!Object.values(Priority).includes(dto.priority)) {
+    return null;
+  },
+
+  /**
+   * Validate task priority
+   */
+  validatePriority(priority: Priority): string | null {
+    if (!Object.values(Priority).includes(priority)) {
       return 'Invalid priority level provided';
     }
-    
     return null;
   },
 
+  /**
+   * Validates the payload for creating a new task
+   */
+  validateCreate(dto: CreateTaskDTO): string | null {
+    return this.validateTitle(dto.text) || 
+           this.validateDescription(dto.description) || 
+           this.validatePriority(dto.priority);
+  },
+
   /**
    * Validates the payload for updating a task
    */
   validateUpdate(dto: UpdateTaskDTO): string | null {
-    if (dto.text !== undefined && dto.text.trim().length === 0) {
-      return 'Task text cannot be empty';
+    if (dto.text !== undefined) {
+      const err = this.validateTitle(dto.text);
+      if (err) return err;
     }
     
-    if (dto.text && dto.text.length > VALIDATION.MAX_TITLE_LENGTH) {
-      return `Task text cannot exceed ${VALIDATION.MAX_TITLE_LENGTH} characters`;
-    }
-
-    if (dto.description && dto.description.length > VALIDATION.MAX_DESC_LENGTH) {
-      return `Description cannot exceed ${VALIDATION.MAX_DESC_LENGTH} characters`;
+    if (dto.description !== undefined) {
+      const err = this.validateDescription(dto.description);
+      if (err) return err;
     }
     
     return null;
diff --git a/src/shared/types/task.types.ts b/src/shared/types/task.types.ts
index 00b22be..ff11db8 100644
--- a/src/shared/types/task.types.ts
+++ b/src/shared/types/task.types.ts
@@ -23,6 +23,15 @@ export enum SortOption {
   PRIORITY_ASC = 'PRIORITY_ASC',
 }
 
+/**
+ * Subtask item structure.
+ */
+export interface SubTask {
+  id: string;
+  text: string;
+  isCompleted: boolean;
+}
+
 /**
  * The core Task object.
  */
@@ -32,6 +41,7 @@ export interface Task {
   description?: string;
   isCompleted: boolean;
   priority: Priority;
+  subtasks: SubTask[];
   createdAt: number;
   updatedAt: number;
   completedAt?: number;
@@ -79,10 +89,11 @@ export interface UpdateTaskDTO {
   isCompleted?: boolean;
   priority?: Priority;
   description?: string;
+  subtasks?: SubTask[];
 }
 
 /**
- * Log entry for the backend logger.
+ * System Log entry structure used in server logs.
  */
 export interface SystemLog {
   id: string;
