diff --git a/index.tsx b/index.tsx
index 1719e08..7970b17 100644
--- a/index.tsx
+++ b/index.tsx
@@ -1,4 +1,3 @@
-
 import React from 'react';
 import ReactDOM from 'react-dom/client';
 import App from './src/client/App';
@@ -13,4 +12,4 @@ root.render(
   <React.StrictMode>
     <App />
   </React.StrictMode>
-);
+);
\ No newline at end of file
diff --git a/src/client/components/FilterBar.tsx b/src/client/components/FilterBar.tsx
index 8f938bc..39e0cce 100644
--- a/src/client/components/FilterBar.tsx
+++ b/src/client/components/FilterBar.tsx
@@ -3,9 +3,9 @@ import React from 'react';
 import { SortOption } from '../../shared/types/task.types';
 
 interface FilterBarProps {
-  currentFilter: 'ALL' | 'ACTIVE' | 'COMPLETED';
+  currentFilter: 'ALL' | 'ACTIVE' | 'COMPLETED' | 'UPCOMING';
   currentSort: SortOption;
-  onFilterChange: (f: 'ALL' | 'ACTIVE' | 'COMPLETED') => void;
+  onFilterChange: (f: 'ALL' | 'ACTIVE' | 'COMPLETED' | 'UPCOMING') => void;
   onSortChange: (s: SortOption) => void;
   onClearCompleted: () => void;
   hasCompleted: boolean;
@@ -21,8 +21,8 @@ export const FilterBar: React.FC<FilterBarProps> = ({
 }) => {
   return (
     <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-6 pb-6 border-b border-slate-100">
-      <div className="flex bg-slate-100/80 p-1 rounded-xl backdrop-blur-sm">
-        {(['ALL', 'ACTIVE', 'COMPLETED'] as const).map((filter) => (
+      <div className="flex flex-wrap gap-1 bg-slate-100/80 p-1 rounded-xl backdrop-blur-sm">
+        {(['ALL', 'ACTIVE', 'COMPLETED', 'UPCOMING'] as const).map((filter) => (
           <button
             key={filter}
             onClick={() => onFilterChange(filter)}
diff --git a/src/client/components/TaskForm.tsx b/src/client/components/TaskForm.tsx
index d873564..8098161 100644
--- a/src/client/components/TaskForm.tsx
+++ b/src/client/components/TaskForm.tsx
@@ -3,13 +3,19 @@ import React, { useState } from 'react';
 import { Priority } from '../../shared/types/task.types';
 
 interface TaskFormProps {
-  onAdd: (text: string, priority: Priority, desc?: string) => Promise<void>;
+  onAdd: (text: string, priority: Priority, desc?: string, initialReminder?: {time: number, message: string}) => Promise<void>;
 }
 
 export const TaskForm: React.FC<TaskFormProps> = ({ onAdd }) => {
   const [text, setText] = useState('');
   const [description, setDescription] = useState('');
   const [priority, setPriority] = useState<Priority>(Priority.MEDIUM);
+  
+  // Reminder State
+  const [hasReminder, setHasReminder] = useState(false);
+  const [reminderDate, setReminderDate] = useState('');
+  const [reminderTime, setReminderTime] = useState('');
+
   const [isExpanded, setIsExpanded] = useState(false);
   const [isSubmitting, setIsSubmitting] = useState(false);
 
@@ -19,16 +25,31 @@ export const TaskForm: React.FC<TaskFormProps> = ({ onAdd }) => {
 
     setIsSubmitting(true);
     try {
-      await onAdd(text, priority, description);
+      let initialReminder = undefined;
+      if (hasReminder && reminderDate && reminderTime) {
+        const ts = new Date(`${reminderDate}T${reminderTime}`).getTime();
+        if (!isNaN(ts)) {
+            initialReminder = { time: ts, message: 'Reminder' };
+        }
+      }
+
+      await onAdd(text, priority, description, initialReminder);
+      
+      // Reset
       setText('');
       setDescription('');
       setPriority(Priority.MEDIUM);
+      setHasReminder(false);
+      setReminderDate('');
+      setReminderTime('');
       setIsExpanded(false);
     } finally {
       setIsSubmitting(false);
     }
   };
 
+  const today = new Date().toISOString().split('T')[0];
+
   return (
     <form onSubmit={handleSubmit} className="mb-10 bg-white p-2 rounded-3xl shadow-xl shadow-indigo-100/50 border border-indigo-50 relative z-10">
       <div className="flex flex-col gap-2">
@@ -47,9 +68,9 @@ export const TaskForm: React.FC<TaskFormProps> = ({ onAdd }) => {
 
         {/* Expanded Options */}
         <div className={`overflow-hidden transition-all duration-500 ease-in-out px-6 ${
-          isExpanded ? 'max-h-56 opacity-100 pb-4' : 'max-h-0 opacity-0 pb-0'
+          isExpanded ? 'max-h-[26rem] opacity-100 pb-4' : 'max-h-0 opacity-0 pb-0'
         }`}>
-          <div className="space-y-5 pt-2">
+          <div className="space-y-4 pt-2">
             <input
               type="text"
               value={description}
@@ -58,7 +79,41 @@ export const TaskForm: React.FC<TaskFormProps> = ({ onAdd }) => {
               className="w-full text-sm text-slate-600 placeholder:text-slate-400 focus:outline-none bg-slate-50 p-3 rounded-xl"
             />
             
-            <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
+            {/* Reminder Toggle Section */}
+            <div className="flex flex-col gap-2">
+              <button
+                type="button"
+                onClick={() => setHasReminder(!hasReminder)}
+                className={`flex items-center gap-2 text-xs font-bold w-fit px-3 py-1.5 rounded-lg border transition-all ${
+                  hasReminder 
+                  ? 'bg-indigo-50 border-indigo-200 text-indigo-600' 
+                  : 'bg-white border-slate-200 text-slate-500 hover:bg-slate-50'
+                }`}
+              >
+                <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" /></svg>
+                {hasReminder ? 'Reminder On' : 'Set Reminder'}
+              </button>
+
+              {hasReminder && (
+                <div className="flex gap-2 animate-in fade-in slide-in-from-top-1">
+                  <input
+                    type="date"
+                    min={today}
+                    value={reminderDate}
+                    onChange={(e) => setReminderDate(e.target.value)}
+                    className="text-xs bg-slate-50 border border-slate-200 rounded-lg px-2 py-1.5 focus:outline-none focus:ring-1 focus:ring-indigo-500"
+                  />
+                  <input
+                    type="time"
+                    value={reminderTime}
+                    onChange={(e) => setReminderTime(e.target.value)}
+                    className="text-xs bg-slate-50 border border-slate-200 rounded-lg px-2 py-1.5 focus:outline-none focus:ring-1 focus:ring-indigo-500"
+                  />
+                </div>
+              )}
+            </div>
+
+            <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4 pt-2">
               <div className="flex gap-2 p-1 bg-slate-100 rounded-xl">
                 {Object.values(Priority).map((p) => (
                   <button
diff --git a/src/client/components/TaskItem.tsx b/src/client/components/TaskItem.tsx
index f0939e9..c8209d2 100644
--- a/src/client/components/TaskItem.tsx
+++ b/src/client/components/TaskItem.tsx
@@ -1,12 +1,17 @@
 
-import React from 'react';
+import React, { useState } from 'react';
 import { Task, Priority } from '../../shared/types/task.types';
 import { formatDate, formatTime } from '../../shared/utils/helpers';
+import { nanoid } from 'nanoid';
+import { ReminderManager } from './ReminderManager';
+import { apiService } from '../services/apiService';
 
 interface TaskItemProps {
   task: Task;
   onToggle: (id: string, status: boolean) => void;
+  onToggleSubtask: (taskId: string, subtaskId: string) => void;
   onDelete: (id: string) => void;
+  onEdit: (id: string, updates: Partial<Task>) => void;
 }
 
 const PriorityBadge: React.FC<{ priority: Priority }> = ({ priority }) => {
@@ -23,7 +28,120 @@ const PriorityBadge: React.FC<{ priority: Priority }> = ({ priority }) => {
   );
 };
 
-export const TaskItem: React.FC<TaskItemProps> = ({ task, onToggle, onDelete }) => {
+export const TaskItem: React.FC<TaskItemProps> = ({ task, onToggle, onToggleSubtask, onDelete, onEdit }) => {
+  const [isEditing, setIsEditing] = useState(false);
+  const [isAddingSubtask, setIsAddingSubtask] = useState(false);
+  const [newSubtaskText, setNewSubtaskText] = useState('');
+
+  const [editForm, setEditForm] = useState({
+    text: task.text,
+    description: task.description || '',
+    priority: task.priority
+  });
+
+  // Calculate subtask progress
+  const completedSubtasks = task.subtasks?.filter(s => s.isCompleted).length || 0;
+  const totalSubtasks = task.subtasks?.length || 0;
+
+  const handleSave = () => {
+    if (!editForm.text.trim()) return;
+    onEdit(task.id, {
+      text: editForm.text,
+      description: editForm.description,
+      priority: editForm.priority
+    });
+    setIsEditing(false);
+  };
+
+  const handleCancel = () => {
+    setEditForm({
+      text: task.text,
+      description: task.description || '',
+      priority: task.priority
+    });
+    setIsEditing(false);
+  };
+
+  const handleAddSubtask = () => {
+    if (!newSubtaskText.trim()) return;
+    const newSubTask = {
+      id: nanoid(),
+      text: newSubtaskText,
+      isCompleted: false
+    };
+    onEdit(task.id, {
+      subtasks: [...(task.subtasks || []), newSubTask]
+    });
+    setNewSubtaskText('');
+    setIsAddingSubtask(false);
+  };
+
+  // Reminder Handlers
+  const handleAddReminder = async (time: number, message: string) => {
+    try {
+      const updated = await apiService.addReminder(task.id, time, message);
+      // Update local state implicitly by parent refresh or local optimisic update if needed,
+      // but here we just trigger onEdit to refresh upstream or let parent handle re-fetch.
+      // Ideally onEdit updates the task in the list.
+      onEdit(task.id, updated); 
+    } catch (e) {
+      alert("Failed to add reminder");
+    }
+  };
+
+  const handleDeleteReminder = async (reminderId: string) => {
+    try {
+      const updated = await apiService.deleteReminder(task.id, reminderId);
+      onEdit(task.id, updated);
+    } catch (e) {
+      alert("Failed to remove reminder");
+    }
+  };
+
+  if (isEditing) {
+    return (
+      <div className="bg-white border-2 border-indigo-500/20 rounded-2xl p-4 shadow-xl shadow-indigo-100/20 relative z-20">
+        <div className="space-y-3">
+          <input
+            type="text"
+            value={editForm.text}
+            onChange={e => setEditForm({ ...editForm, text: e.target.value })}
+            className="w-full text-base font-medium text-slate-800 bg-slate-50 border border-slate-200 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500/20"
+            autoFocus
+          />
+          <textarea
+            value={editForm.description}
+            onChange={e => setEditForm({ ...editForm, description: e.target.value })}
+            placeholder="Add description..."
+            className="w-full text-sm text-slate-600 bg-slate-50 border border-slate-200 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500/20 resize-none"
+            rows={2}
+          />
+          <div className="flex justify-between items-center pt-2">
+            <div className="flex gap-1 bg-slate-100 p-1 rounded-lg">
+               {Object.values(Priority).map(p => (
+                 <button
+                   key={p}
+                   onClick={() => setEditForm({ ...editForm, priority: p })}
+                   className={`px-3 py-1 text-[10px] font-bold uppercase rounded-md transition-colors ${
+                     editForm.priority === p ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-400 hover:text-slate-600'
+                   }`}
+                 >
+                   {p}
+                 </button>
+               ))}
+            </div>
+            <div className="flex gap-2">
+              <button onClick={handleCancel} className="text-xs font-bold text-slate-500 hover:bg-slate-100 px-3 py-1.5 rounded-lg">Cancel</button>
+              <button onClick={handleSave} className="text-xs font-bold text-white bg-indigo-600 hover:bg-indigo-700 px-4 py-1.5 rounded-lg shadow-md shadow-indigo-200">Save</button>
+            </div>
+          </div>
+        </div>
+      </div>
+    );
+  }
+
+  const upcomingReminder = task.reminders && task.reminders.find(r => r.time > Date.now());
+
   return (
     <div className={`group relative bg-white border rounded-2xl p-4 transition-all duration-300 ${
       task.isCompleted 
@@ -46,24 +164,102 @@ export const TaskItem: React.FC<TaskItemProps> = ({ task, onToggle, onDelete })
         </button>
 
         {/* Content */}
-        <div className="flex-1 min-w-0">
+        <div className="flex-1 min-w-0 pr-16">
           <div className="flex items-center gap-2 mb-1 flex-wrap">
-            <h4 className={`text-base font-medium truncate pr-8 transition-colors ${
+            <h4 className={`text-base font-medium truncate max-w-full transition-colors ${
               task.isCompleted ? 'text-slate-400 line-through decoration-slate-300' : 'text-slate-800'
             }`}>
               {task.text}
             </h4>
             <PriorityBadge priority={task.priority} />
+            
+            {/* Reminder Badge (Small) if collapsed */}
+            {!task.isCompleted && upcomingReminder && (
+               <span className="flex items-center gap-1 text-[10px] font-bold text-indigo-600 bg-indigo-50 px-2 py-0.5 rounded-full border border-indigo-100">
+                 <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
+                 {formatDate(upcomingReminder.time)}
+               </span>
+            )}
+
+            {/* Subtask Progress Badge */}
+            {totalSubtasks > 0 && (
+              <span className={`text-[10px] font-bold px-1.5 py-0.5 rounded-md flex items-center gap-1 ${
+                completedSubtasks === totalSubtasks 
+                ? 'bg-emerald-100 text-emerald-700' 
+                : 'bg-slate-100 text-slate-500'
+              }`}>
+                <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
+                   <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
+                </svg>
+                {completedSubtasks}/{totalSubtasks}
+              </span>
+            )}
           </div>
           
           {task.description && (
-            <p className={`text-sm mb-2 ${task.isCompleted ? 'text-slate-300' : 'text-slate-500'}`}>
+            <p className={`text-sm mb-2 break-words ${task.isCompleted ? 'text-slate-300' : 'text-slate-500'}`}>
               {task.description}
             </p>
           )}
+
+          {/* Subtasks List */}
+          {(task.subtasks?.length > 0 || isAddingSubtask) && !task.isCompleted && (
+            <div className="mt-3 space-y-1 mb-2">
+              {task.subtasks.map(sub => (
+                <div key={sub.id} className="flex items-center gap-2 group/sub">
+                  <button 
+                    onClick={() => onToggleSubtask(task.id, sub.id)}
+                    className={`w-4 h-4 rounded border flex items-center justify-center transition-all ${
+                      sub.isCompleted 
+                      ? 'bg-indigo-500 border-indigo-500 text-white' 
+                      : 'border-slate-300 hover:border-indigo-400 bg-white'
+                    }`}
+                  >
+                    {sub.isCompleted && <svg className="w-2.5 h-2.5" viewBox="0 0 24 24" fill="currentColor"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>}
+                  </button>
+                  <span className={`text-xs transition-colors ${sub.isCompleted ? 'text-slate-400 line-through' : 'text-slate-600'}`}>
+                    {sub.text}
+                  </span>
+                </div>
+              ))}
+            </div>
+          )}
           
-          <div className="flex items-center gap-3 text-xs text-slate-400 font-medium">
-            <span>{formatDate(task.createdAt)}</span>
+          {/* Add Subtask Input */}
+          {isAddingSubtask ? (
+             <div className="flex items-center gap-2 mt-2 mb-2">
+               <input
+                 type="text"
+                 value={newSubtaskText}
+                 onChange={(e) => setNewSubtaskText(e.target.value)}
+                 placeholder="New subtask..."
+                 className="text-xs border rounded-lg px-2 py-1 focus:outline-none focus:ring-1 focus:ring-indigo-500 w-40"
+                 autoFocus
+                 onKeyDown={(e) => e.key === 'Enter' && handleAddSubtask()}
+               />
+               <button onClick={handleAddSubtask} className="text-xs font-bold text-white bg-indigo-500 px-2 py-1 rounded-lg">Add</button>
+               <button onClick={() => setIsAddingSubtask(false)} className="text-xs text-slate-500 px-2">Cancel</button>
+             </div>
+          ) : !task.isCompleted && (
+             <button 
+               onClick={() => setIsAddingSubtask(true)}
+               className="text-[10px] font-bold text-indigo-500 hover:text-indigo-700 hover:underline mt-1 flex items-center gap-1 mb-2"
+             >
+               + Add subtask
+             </button>
+          )}
+
+          {/* Reminder Manager */}
+          {!task.isCompleted && (
+            <ReminderManager 
+              reminders={task.reminders || []} 
+              onAdd={handleAddReminder} 
+              onDelete={handleDeleteReminder}
+            />
+          )}
+
+          <div className="flex items-center gap-3 text-xs text-slate-400 font-medium mt-3 border-t border-slate-50 pt-2">
+            <span>Created {formatDate(task.createdAt)}</span>
             {task.isCompleted && task.completedAt && (
               <span className="text-emerald-600/70 bg-emerald-50 px-1.5 py-0.5 rounded-md">
                 Done at {formatTime(task.completedAt)}
@@ -72,15 +268,27 @@ export const TaskItem: React.FC<TaskItemProps> = ({ task, onToggle, onDelete })
           </div>
         </div>
 
-        {/* Delete Action */}
-        <button
-          onClick={() => onDelete(task.id)}
-          className="absolute top-4 right-4 text-slate-300 hover:text-red-500 p-2 rounded-xl hover:bg-red-50 transition-all opacity-0 group-hover:opacity-100 transform hover:scale-110"
-        >
-          <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
-            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
-          </svg>
-        </button>
+        {/* Actions */}
+        <div className="absolute top-4 right-4 flex gap-1 opacity-0 group-hover:opacity-100 transition-all duration-200 transform translate-x-2 group-hover:translate-x-0">
+          <button
+            onClick={() => setIsEditing(true)}
+            className="text-slate-400 hover:text-indigo-600 p-2 rounded-xl hover:bg-indigo-50 transition-colors"
+            title="Edit"
+          >
+            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
+              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
+            </svg>
+          </button>
+          <button
+            onClick={() => onDelete(task.id)}
+            className="text-slate-400 hover:text-red-500 p-2 rounded-xl hover:bg-red-50 transition-colors"
+            title="Delete"
+          >
+            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
+              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
+            </svg>
+          </button>
+        </div>
       </div>
     </div>
   );
diff --git a/src/client/services/apiService.ts b/src/client/services/apiService.ts
index c53d3aa..e42743c 100644
--- a/src/client/services/apiService.ts
+++ b/src/client/services/apiService.ts
@@ -4,8 +4,9 @@
 // Path: src/client/services/apiService.ts
 // ============================================================================
 
-import { Task, CreateTaskDTO, UpdateTaskDTO, TaskStats, Priority } from '../../shared/types/task.types';
+import { Task, CreateTaskDTO, UpdateTaskDTO, TaskStats, Priority, TaskTag } from '../../shared/types/task.types';
 import { TaskController } from '../../server/index';
+import { ReminderController } from '../../server/controllers/reminderController';
 
 /**
  * Handles communication between Frontend components and the Backend Controller.
@@ -18,13 +19,19 @@ export const apiService = {
     return response.data;
   },
 
-  async createTask(text: string, priority: Priority, description?: string): Promise<Task> {
-    const payload: CreateTaskDTO = { text, priority, description };
+  async createTask(text: string, priority: Priority, description?: string, initialReminder?: {time: number, message: string}): Promise<Task> {
+    const payload: CreateTaskDTO = { text, priority, description, initialReminder };
     const response = await TaskController.createTask(payload);
     if (!response.success || !response.data) throw new Error(response.error);
     return response.data;
   },
 
+  async updateTask(id: string, updates: UpdateTaskDTO): Promise<Task> {
+    const response = await TaskController.updateTask(id, updates);
+    if (!response.success || !response.data) throw new Error(response.error);
+    return response.data;
+  },
+
   async toggleTask(id: string, currentStatus: boolean): Promise<Task> {
     const payload: UpdateTaskDTO = { isCompleted: !currentStatus };
     const response = await TaskController.updateTask(id, payload);
@@ -32,6 +39,12 @@ export const apiService = {
     return response.data;
   },
 
+  async toggleSubtask(taskId: string, subtaskId: string): Promise<Task> {
+    const response = await TaskController.toggleSubtask(taskId, subtaskId);
+    if (!response.success || !response.data) throw new Error(response.error);
+    return response.data;
+  },
+
   async deleteTask(id: string): Promise<void> {
     const response = await TaskController.deleteTask(id);
     if (!response.success) throw new Error(response.error);
@@ -47,5 +60,33 @@ export const apiService = {
     const response = await TaskController.getStats();
     if (!response.success || !response.data) throw new Error(response.error);
     return response.data;
+  },
+
+  // --- Reminder Methods ---
+
+  async addReminder(taskId: string, time: number, message: string): Promise<Task> {
+    const response = await ReminderController.addReminder(taskId, time, message);
+    if (!response.success || !response.data) throw new Error(response.error);
+    return response.data;
+  },
+
+  async deleteReminder(taskId: string, reminderId: string): Promise<Task> {
+    const response = await ReminderController.deleteReminder(taskId, reminderId);
+    if (!response.success || !response.data) throw new Error(response.error);
+    return response.data;
+  },
+
+  // --- Tag Methods ---
+
+  async createTag(name: string, color: string): Promise<TaskTag> {
+    const response = await TaskController.createTag(name, color);
+    if (!response.success || !response.data) throw new Error(response.error);
+    return response.data;
+  },
+
+  async fetchTags(): Promise<TaskTag[]> {
+    const response = await TaskController.getTags();
+    if (!response.success || !response.data) throw new Error(response.error);
+    return response.data;
   }
 };
diff --git a/src/server/controllers/taskController.ts b/src/server/controllers/taskController.ts
index 4028278..fd86a73 100644
--- a/src/server/controllers/taskController.ts
+++ b/src/server/controllers/taskController.ts
@@ -4,10 +4,12 @@
 // Path: src/server/controllers/taskController.ts
 // ============================================================================
 
-import { Task, ApiResponse, CreateTaskDTO, UpdateTaskDTO, TaskStats } from '../../shared/types/task.types';
+import { Task, ApiResponse, CreateTaskDTO, UpdateTaskDTO, TaskStats, TaskTag } from '../../shared/types/task.types';
 import { TaskValidator } from '../validators/taskValidator';
 import { taskService } from '../services/taskService';
+import { tagService } from '../services/tagService';
 import { delay } from '../../shared/utils/helpers';
+import { nanoid } from 'nanoid';
 
 export const TaskController = {
   
@@ -19,15 +21,17 @@ export const TaskController = {
       statusCode,
       meta: {
         timestamp: Date.now(),
-        requestId: crypto.randomUUID()
+        requestId: nanoid()
       }
     };
   },
 
+  // --- Task Endpoints ---
+
   async getTasks(): Promise<ApiResponse<Task[]>> {
     await delay(300); // Simulate network
     try {
-      const tasks = taskService.getAll();
+      const tasks = await taskService.getAll();
       return this._response(true, tasks);
     } catch (e) {
       return this._response(false, undefined, 'Internal Server Error', 500);
@@ -41,7 +45,7 @@ export const TaskController = {
     if (error) return this._response(false, undefined, error, 400);
 
     try {
-      const task = taskService.create(dto);
+      const task = await taskService.create(dto);
       return this._response(true, task, undefined, 201);
     } catch (e) {
       return this._response(false, undefined, 'Creation failed', 500);
@@ -55,7 +59,7 @@ export const TaskController = {
     if (error) return this._response(false, undefined, error, 400);
 
     try {
-      const task = taskService.update(id, dto);
+      const task = await taskService.update(id, dto);
       if (!task) return this._response(false, undefined, 'Task not found', 404);
       return this._response(true, task);
     } catch (e) {
@@ -63,10 +67,21 @@ export const TaskController = {
     }
   },
 
+  async toggleSubtask(taskId: string, subtaskId: string): Promise<ApiResponse<Task>> {
+    await delay(150);
+    try {
+      const task = await taskService.toggleSubtask(taskId, subtaskId);
+      if (!task) return this._response(false, undefined, 'Task or subtask not found', 404);
+      return this._response(true, task);
+    } catch (e) {
+      return this._response(false, undefined, 'Subtask toggle failed', 500);
+    }
+  },
+
   async deleteTask(id: string): Promise<ApiResponse<null>> {
     await delay(200);
     try {
-      const success = taskService.delete(id);
+      const success = await taskService.delete(id);
       if (!success) return this._response(false, undefined, 'Task not found', 404);
       return this._response(true, null, undefined, 204);
     } catch (e) {
@@ -77,7 +92,7 @@ export const TaskController = {
   async clearCompleted(): Promise<ApiResponse<{ count: number }>> {
     await delay(400);
     try {
-      const count = taskService.clearCompleted();
+      const count = await taskService.clearCompleted();
       return this._response(true, { count });
     } catch (e) {
       return this._response(false, undefined, 'Clear failed', 500);
@@ -85,12 +100,34 @@ export const TaskController = {
   },
 
   async getStats(): Promise<ApiResponse<TaskStats>> {
-    // Stats usually fast
     try {
-      const stats = taskService.getStats();
+      const stats = await taskService.getStats();
       return this._response(true, stats);
     } catch (e) {
       return this._response(false, undefined, 'Stats failed', 500);
     }
+  },
+
+  // --- Tag Endpoints ---
+
+  async getTags(): Promise<ApiResponse<TaskTag[]>> {
+    await delay(200);
+    try {
+      const tags = await tagService.getAllTags();
+      return this._response(true, tags);
+    } catch (e) {
+      return this._response(false, undefined, 'Failed to fetch tags', 500);
+    }
+  },
+
+  async createTag(name: string, color: string): Promise<ApiResponse<TaskTag>> {
+    await delay(200);
+    if (!name || !color) return this._response(false, undefined, 'Name and color required', 400);
+    try {
+      const tag = await tagService.createTag(name, color);
+      return this._response(true, tag, undefined, 201);
+    } catch (e) {
+      return this._response(false, undefined, 'Failed to create tag', 500);
+    }
   }
 };
diff --git a/src/server/db/jsonDatabase.ts b/src/server/db/jsonDatabase.ts
index 991a1a6..cd6abdc 100644
--- a/src/server/db/jsonDatabase.ts
+++ b/src/server/db/jsonDatabase.ts
@@ -1,17 +1,40 @@
 
+
 // ============================================================================
 // DATABASE LAYER
 // Path: src/server/db/jsonDatabase.ts
 // ============================================================================
 
-import { Task, SystemLog } from '../../shared/types/task.types';
+import { Task, SystemLog, TaskTag } from '../../shared/types/task.types';
 import { DB_KEYS } from '../../shared/constants';
 
 class JsonDatabase {
+  // In-memory fallback for environments without localStorage (like Node.js tests)
+  private memoryStorage: Record<string, string> = {};
+
+  // Check if we are running in a browser environment
+  private get isBrowser(): boolean {
+    return typeof window !== 'undefined' && typeof window.localStorage !== 'undefined';
+  }
+
+  private getItem(key: string): string | null {
+    if (this.isBrowser) {
+      return localStorage.getItem(key);
+    }
+    return this.memoryStorage[key] || null;
+  }
+
+  private setItem(key: string, value: string): void {
+    if (this.isBrowser) {
+      localStorage.setItem(key, value);
+    } else {
+      this.memoryStorage[key] = value;
+    }
+  }
   
   readTasks(): Task[] {
     try {
-      const data = localStorage.getItem(DB_KEYS.TASKS);
+      const data = this.getItem(DB_KEYS.TASKS);
       return data ? JSON.parse(data) : [];
     } catch (e) {
       console.error("[DB] Read Error", e);
@@ -21,28 +44,51 @@ class JsonDatabase {
 
   writeTasks(tasks: Task[]): void {
     try {
-      localStorage.setItem(DB_KEYS.TASKS, JSON.stringify(tasks));
+      this.setItem(DB_KEYS.TASKS, JSON.stringify(tasks));
     } catch (e) {
       console.error("[DB] Write Error", e);
     }
   }
 
+  readTags(): TaskTag[] {
+    try {
+      const data = this.getItem(DB_KEYS.TAGS);
+      return data ? JSON.parse(data) : [];
+    } catch (e) {
+      console.error("[DB] Read Tags Error", e);
+      return [];
+    }
+  }
+
+  writeTags(tags: TaskTag[]): void {
+    try {
+      this.setItem(DB_KEYS.TAGS, JSON.stringify(tags));
+    } catch (e) {
+      console.error("[DB] Write Tags Error", e);
+    }
+  }
+
   writeLog(log: SystemLog): void {
     try {
       const logs = this.readLogs();
       logs.push(log);
       // Limit logs to prevent localStorage quotas
       if (logs.length > 200) logs.shift();
-      localStorage.setItem(DB_KEYS.LOGS, JSON.stringify(logs));
+      this.setItem(DB_KEYS.LOGS, JSON.stringify(logs));
     } catch (e) {
       console.error("[DB] Log Error", e);
     }
   }
 
   readLogs(): SystemLog[] {
-    const data = localStorage.getItem(DB_KEYS.LOGS);
-    return data ? JSON.parse(data) : [];
+    try {
+      const data = this.getItem(DB_KEYS.LOGS);
+      return data ? JSON.parse(data) : [];
+    } catch (e) {
+       console.error("[DB] Log Read Error", e);
+       return [];
+    }
   }
 }
 
-export const db = new JsonDatabase();
+export const db = new JsonDatabase();
\ No newline at end of file
diff --git a/src/server/services/taskService.ts b/src/server/services/taskService.ts
index 16d21d4..bb18bef 100644
--- a/src/server/services/taskService.ts
+++ b/src/server/services/taskService.ts
@@ -4,8 +4,9 @@
 // Path: src/server/services/taskService.ts
 // ============================================================================
 
-import { Task, CreateTaskDTO, UpdateTaskDTO, TaskStats, Priority, SystemLog } from '../../shared/types/task.types';
+import { Task, CreateTaskDTO, UpdateTaskDTO, TaskStats, Priority, SystemLog, TaskReminder, TaskTag } from '../../shared/types/task.types';
 import { db } from '../db/jsonDatabase';
+import { nanoid } from 'nanoid';
 
 // Internal Logger Service
 const Logger = {
@@ -16,7 +17,7 @@ const Logger = {
 
 function log(level: 'INFO' | 'WARN' | 'ERROR', message: string, context?: any) {
   const entry: SystemLog = {
-    id: crypto.randomUUID(),
+    id: nanoid(),
     level,
     message,
     timestamp: Date.now(),
@@ -50,15 +51,26 @@ class TaskService {
     }
 
     const newTask: Task = {
-      id: crypto.randomUUID(),
+      id: nanoid(),
       text: dto.text.trim(),
       description: dto.description?.trim(),
       priority: dto.priority,
       isCompleted: false,
+      subtasks: [],
+      reminders: [],
+      tags: [],
       createdAt: Date.now(),
       updatedAt: Date.now(),
     };
 
+    if (dto.initialReminder) {
+      newTask.reminders.push({
+        id: nanoid(),
+        time: dto.initialReminder.time,
+        message: dto.initialReminder.message
+      });
+    }
+
     tasks.push(newTask);
     db.writeTasks(tasks);
     Logger.info('Task created', { id: newTask.id });
@@ -96,6 +108,29 @@ class TaskService {
     return updatedTask;
   }
 
+  toggleSubtask(taskId: string, subtaskId: string): Task | null {
+    const tasks = db.readTasks();
+    const taskIndex = tasks.findIndex(t => t.id === taskId);
+    
+    if (taskIndex === -1) return null;
+    
+    const task = tasks[taskIndex];
+    if (!task.subtasks) task.subtasks = []; // Defensive
+
+    const subtaskIndex = task.subtasks.findIndex(s => s.id === subtaskId);
+    if (subtaskIndex === -1) return null;
+
+    // Toggle status
+    task.subtasks[subtaskIndex].isCompleted = !task.subtasks[subtaskIndex].isCompleted;
+    task.updatedAt = Date.now();
+
+    tasks[taskIndex] = task;
+    db.writeTasks(tasks);
+    Logger.info('Subtask toggled', { taskId, subtaskId });
+
+    return task;
+  }
+
   delete(id: string): boolean {
     const tasks = db.readTasks();
     const filtered = tasks.filter(t => t.id !== id);
@@ -133,6 +168,120 @@ class TaskService {
       completionRate: total > 0 ? Math.round((completed / total) * 100) : 0
     };
   }
+
+  // --- Reminder Methods ---
+
+  addReminderToTask(taskId: string, time: number, message: string): Task | null {
+    const tasks = db.readTasks();
+    const index = tasks.findIndex(t => t.id === taskId);
+    if (index === -1) return null;
+
+    const task = tasks[index];
+    if (!task.reminders) task.reminders = [];
+
+    const reminder: TaskReminder = {
+      id: nanoid(),
+      time,
+      message: message.trim() || 'Reminder'
+    };
+
+    task.reminders.push(reminder);
+    // Sort reminders by time
+    task.reminders.sort((a, b) => a.time - b.time);
+    
+    task.updatedAt = Date.now();
+    tasks[index] = task;
+    
+    db.writeTasks(tasks);
+    Logger.info('Reminder added', { taskId, reminderId: reminder.id });
+    return task;
+  }
+
+  removeReminderFromTask(taskId: string, reminderId: string): Task | null {
+    const tasks = db.readTasks();
+    const index = tasks.findIndex(t => t.id === taskId);
+    if (index === -1) return null;
+
+    const task = tasks[index];
+    if (!task.reminders) return task;
+
+    task.reminders = task.reminders.filter(r => r.id !== reminderId);
+    task.updatedAt = Date.now();
+    tasks[index] = task;
+
+    db.writeTasks(tasks);
+    Logger.info('Reminder removed', { taskId, reminderId });
+    return task;
+  }
+
+  // --- Tag Methods ---
+
+  addTagToTask(taskId: string, tagId: string): Task | null {
+    const tasks = db.readTasks();
+    const index = tasks.findIndex(t => t.id === taskId);
+    if (index === -1) return null;
+
+    // Verify tag exists
+    const tags = db.readTags();
+    const tag = tags.find(t => t.id === tagId);
+    if (!tag) return null;
+
+    const task = tasks[index];
+    if (!task.tags) task.tags = [];
+
+    // Avoid duplicates
+    if (!task.tags.some(t => t.id === tagId)) {
+      task.tags.push(tag);
+      task.updatedAt = Date.now();
+      tasks[index] = task;
+      db.writeTasks(tasks);
+      Logger.info('Tag added to task', { taskId, tagId });
+    }
+
+    return task;
+  }
+
+  removeTagFromTask(taskId: string, tagId: string): Task | null {
+    const tasks = db.readTasks();
+    const index = tasks.findIndex(t => t.id === taskId);
+    if (index === -1) return null;
+
+    const task = tasks[index];
+    if (!task.tags) return task;
+
+    const initialLength = task.tags.length;
+    task.tags = task.tags.filter(t => t.id !== tagId);
+
+    if (task.tags.length !== initialLength) {
+      task.updatedAt = Date.now();
+      tasks[index] = task;
+      db.writeTasks(tasks);
+      Logger.info('Tag removed from task', { taskId, tagId });
+    }
+
+    return task;
+  }
+
+  async removeTagFromAllTasks(tagId: string): Promise<void> {
+    const tasks = await db.readTasks();
+    let updated = false;
+    
+    const newTasks = tasks.map(task => {
+        if (task.tags && task.tags.some(t => t.id === tagId)) {
+            updated = true;
+            return {
+                ...task,
+                tags: task.tags.filter(t => t.id !== tagId)
+            };
+        }
+        return task;
+    });
+
+    if (updated) {
+        await db.writeTasks(newTasks);
+        Logger.info('Tag removed from all tasks', { tagId });
+    }
+  }
 }
 
 export const taskService = new TaskService();
diff --git a/src/shared/constants.ts b/src/shared/constants.ts
index 30fcd12..3694540 100644
--- a/src/shared/constants.ts
+++ b/src/shared/constants.ts
@@ -1,4 +1,5 @@
 
+
 // ============================================================================
 // CONSTANTS
 // Path: src/shared/constants.ts
@@ -11,6 +12,7 @@ export const APP_VERSION = "2.1.0";
 export const DB_KEYS = {
   TASKS: 'simplydone_tasks_v3',
   LOGS: 'simplydone_logs_v3',
+  TAGS: 'simplydone_tags_v3',
 };
 
 // Validation Constraints
@@ -24,4 +26,4 @@ export const PRIORITY_COLORS = {
   HIGH: 'text-red-600 bg-red-50 border-red-200',
   MEDIUM: 'text-amber-600 bg-amber-50 border-amber-200',
   LOW: 'text-blue-600 bg-blue-50 border-blue-200',
-};
+};
\ No newline at end of file
diff --git a/src/shared/types/task.types.ts b/src/shared/types/task.types.ts
index 00b22be..b8dafb5 100644
--- a/src/shared/types/task.types.ts
+++ b/src/shared/types/task.types.ts
@@ -1,4 +1,5 @@
 
+
 // ============================================================================
 // SHARED TYPES
 // Path: src/shared/types/task.types.ts
@@ -23,6 +24,33 @@ export enum SortOption {
   PRIORITY_ASC = 'PRIORITY_ASC',
 }
 
+/**
+ * Subtask item structure.
+ */
+export interface SubTask {
+  id: string;
+  text: string;
+  isCompleted: boolean;
+}
+
+/**
+ * Reminder structure.
+ */
+export interface TaskReminder {
+  id: string;
+  time: number;
+  message: string;
+}
+
+/**
+ * Tag structure.
+ */
+export interface TaskTag {
+  id: string;
+  name: string;
+  color: string;
+}
+
 /**
  * The core Task object.
  */
@@ -32,6 +60,9 @@ export interface Task {
   description?: string;
   isCompleted: boolean;
   priority: Priority;
+  subtasks: SubTask[];
+  reminders: TaskReminder[];
+  tags: TaskTag[];
   createdAt: number;
   updatedAt: number;
   completedAt?: number;
@@ -69,6 +100,10 @@ export interface CreateTaskDTO {
   text: string;
   priority: Priority;
   description?: string;
+  initialReminder?: {
+    time: number;
+    message: string;
+  };
 }
 
 /**
@@ -79,10 +114,11 @@ export interface UpdateTaskDTO {
   isCompleted?: boolean;
   priority?: Priority;
   description?: string;
+  subtasks?: SubTask[];
 }
 
 /**
- * Log entry for the backend logger.
+ * System Log entry structure used in server logs.
  */
 export interface SystemLog {
   id: string;
@@ -90,4 +126,4 @@ export interface SystemLog {
   message: string;
   timestamp: number;
   context?: any;
-}
+}
\ No newline at end of file
diff --git a/tsconfig.json b/tsconfig.json
index 2c6eed5..9546a01 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -1,29 +1,34 @@
+
 {
   "compilerOptions": {
-    "target": "ES2022",
-    "experimentalDecorators": true,
-    "useDefineForClassFields": false,
+    "target": "ES2020",
+    "useDefineForClassFields": true,
+    "lib": ["ES2020", "DOM", "DOM.Iterable"],
     "module": "ESNext",
-    "lib": [
-      "ES2022",
-      "DOM",
-      "DOM.Iterable"
-    ],
     "skipLibCheck": true,
-    "types": [
-      "node"
-    ],
+
+    /* Bundler mode */
     "moduleResolution": "bundler",
+    "allowImportingTsExtensions": true,
+    "resolveJsonModule": true,
     "isolatedModules": true,
-    "moduleDetection": "force",
-    "allowJs": true,
+    "noEmit": true,
     "jsx": "react-jsx",
+
+    /* Linting */
+    "strict": true,
+    "noUnusedLocals": false,
+    "noUnusedParameters": false,
+    "noFallthroughCasesInSwitch": true,
+    
+    /* Path Aliases */
+    "baseUrl": ".",
     "paths": {
-      "@/*": [
-        "./*"
-      ]
+      "@/*": ["./src/*"]
     },
-    "allowImportingTsExtensions": true,
-    "noEmit": true
-  }
-}
\ No newline at end of file
+    
+    /* Types */
+    "types": ["node", "vite/client"]
+  },
+  "include": ["src", "index.tsx", "tasks"]
+}
