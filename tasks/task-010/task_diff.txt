diff --git a/src/client/App.tsx b/src/client/App.tsx
index bcdbba9..7fe707a 100644
--- a/src/client/App.tsx
+++ b/src/client/App.tsx
@@ -1,13 +1,112 @@
 
 import React, { useEffect, useState, useMemo } from 'react';
-import { Task, Priority, TaskStats, SortOption } from '../shared/types/task.types';
+import { Task, Priority, TaskStats, SortOption, TaskObserver, TaskEvent } from '../shared/types/task.types';
 import { getPriorityWeight } from '../shared/utils/helpers';
 import { apiService } from './services/apiService';
+import { taskService } from '../server/services/taskService';
 import { TaskForm } from './components/TaskForm';
 import { FilterBar } from './components/FilterBar';
 import { StatsCard } from './components/StatsCard';
 import { TaskList } from './components/TaskList';
 
+// --- Reducer Types & Logic (Exported for Testing) ---
+
+export type PendingOperation = 
+  | { id: string; type: 'CREATE'; taskId: string }
+  | { id: string; type: 'UPDATE'; taskId: string; previousState: Task }
+  | { id: string; type: 'DELETE'; taskId: string; previousState: Task };
+
+export interface TaskState {
+  tasks: Task[];
+  pendingActions: PendingOperation[];
+  error: string | null;
+}
+
+export const initialState: TaskState = {
+  tasks: [],
+  pendingActions: [],
+  error: null
+};
+
+export type OptimisticAction = 
+  | { type: 'ADD_TASK_OPTIMISTIC'; payload: { tempId: string; task: Task } }
+  | { type: 'UPDATE_TASK_OPTIMISTIC'; payload: { id: string; updates: Partial<Task>; original: Task; actionId: string } }
+  | { type: 'DELETE_TASK_OPTIMISTIC'; payload: { id: string; original: Task; actionId: string } }
+  | { type: 'ROLLBACK_ACTION'; payload: { actionId: string; error: string } }
+  | { type: 'COMMIT_ACTION'; payload: { tempId?: string; finalTask?: Task; actionId: string } }
+  | { type: 'SET_TASKS'; payload: Task[] };
+
+export function taskReducer(state: TaskState, action: OptimisticAction): TaskState {
+  switch (action.type) {
+    case 'ADD_TASK_OPTIMISTIC':
+      return {
+        ...state,
+        tasks: [action.payload.task, ...state.tasks],
+        pendingActions: [...state.pendingActions, { 
+            id: action.payload.tempId, type: 'CREATE', taskId: action.payload.tempId 
+        }]
+      };
+    case 'UPDATE_TASK_OPTIMISTIC':
+      return {
+        ...state,
+        tasks: state.tasks.map(t => t.id === action.payload.id ? { ...t, ...action.payload.updates } : t),
+        pendingActions: [...state.pendingActions, { 
+            id: action.payload.actionId, 
+            type: 'UPDATE', 
+            taskId: action.payload.id, 
+            previousState: action.payload.original 
+        }]
+      };
+    case 'DELETE_TASK_OPTIMISTIC':
+       return {
+        ...state,
+        tasks: state.tasks.filter(t => t.id !== action.payload.id),
+        pendingActions: [...state.pendingActions, {
+            id: action.payload.actionId,
+            type: 'DELETE',
+            taskId: action.payload.id,
+            previousState: action.payload.original
+        }]
+       };
+    case 'ROLLBACK_ACTION':
+        const actionToRollback = state.pendingActions.find(a => a.id === action.payload.actionId);
+        if (!actionToRollback) return { ...state, error: action.payload.error };
+
+        let rolledBackTasks = [...state.tasks];
+        
+        if (actionToRollback.type === 'CREATE') {
+            rolledBackTasks = rolledBackTasks.filter(t => t.id !== actionToRollback.taskId);
+        } else if (actionToRollback.type === 'UPDATE') {
+            const prev = actionToRollback.previousState;
+            rolledBackTasks = rolledBackTasks.map(t => t.id === actionToRollback.taskId ? prev : t);
+        } else if (actionToRollback.type === 'DELETE') {
+            const prev = actionToRollback.previousState;
+            rolledBackTasks = [...rolledBackTasks, prev];
+        }
+
+        return {
+            ...state,
+            tasks: rolledBackTasks,
+            pendingActions: state.pendingActions.filter(a => a.id !== action.payload.actionId),
+            error: action.payload.error
+        };
+    case 'COMMIT_ACTION':
+        let committedTasks = [...state.tasks];
+        if (action.payload.tempId && action.payload.finalTask) {
+             committedTasks = committedTasks.map(t => t.id === action.payload.tempId ? action.payload.finalTask : t);
+        }
+        return {
+            ...state,
+            tasks: committedTasks,
+            pendingActions: state.pendingActions.filter(a => a.id !== action.payload.actionId)
+        };
+    case 'SET_TASKS':
+        return { ...state, tasks: action.payload };
+    default:
+      return state;
+  }
+}
+
 const App: React.FC = () => {
   // --- State ---
   const [tasks, setTasks] = useState<Task[]>([]);
@@ -20,6 +119,17 @@ const App: React.FC = () => {
   const [sort, setSort] = useState<SortOption>(SortOption.NEWEST);
 
   // --- Actions ---
+  const loadTasks = async () => {
+    // Direct read from service for instant updates via observer
+    // Now async due to DB upgrade
+    try {
+      const data = await taskService.getAll();
+      setTasks([...data]); 
+    } catch (e) {
+      console.error("Failed to load tasks via observer", e);
+    }
+  };
+
   const refreshData = async () => {
     try {
       setLoading(true);
@@ -38,48 +148,58 @@ const App: React.FC = () => {
   };
 
   useEffect(() => {
+    // Initial Load
     refreshData();
+
+    // Subscribe to Task Changes
+    const observer: TaskObserver = {
+      update: (event: TaskEvent) => {
+        // On any change, reload the local task list
+        loadTasks();
+        // Also refresh stats if relevant
+        apiService.getStats().then(setStats).catch(console.error);
+      }
+    };
+
+    taskService.subscribe(observer);
+    return () => taskService.unsubscribe(observer);
   }, []);
 
-  const updateStats = async () => {
+  const handleAddTask = async (text: string, priority: Priority, desc?: string) => {
     try {
-      const newStats = await apiService.getStats();
-      setStats(newStats);
-    } catch (e) { console.error(e); }
+      await apiService.createTask(text, priority, desc);
+    } catch (err: any) { alert(err.message); }
   };
 
-  const handleAddTask = async (text: string, priority: Priority, desc?: string) => {
+  const handleEditTask = async (id: string, updates: Partial<Task>) => {
     try {
-      const newTask = await apiService.createTask(text, priority, desc);
-      setTasks(prev => [newTask, ...prev]);
-      await updateStats();
+      await apiService.updateTask(id, updates);
     } catch (err: any) { alert(err.message); }
   };
 
   const handleToggleTask = async (id: string, currentStatus: boolean) => {
-    setTasks(prev => prev.map(t => t.id === id ? { ...t, isCompleted: !currentStatus } : t));
     try {
       await apiService.toggleTask(id, currentStatus);
-      await updateStats();
-    } catch (err: any) { refreshData(); alert(err.message); }
+    } catch (err: any) { alert(err.message); }
+  };
+
+  const handleToggleSubtask = async (taskId: string, subtaskId: string) => {
+     try {
+       await apiService.toggleSubtask(taskId, subtaskId);
+     } catch (err: any) { alert(err.message); }
   };
 
   const handleDeleteTask = async (id: string) => {
     if (!confirm('Delete this task?')) return;
-    const old = [...tasks];
-    setTasks(prev => prev.filter(t => t.id !== id));
     try {
       await apiService.deleteTask(id);
-      await updateStats();
-    } catch (err: any) { setTasks(old); alert(err.message); }
+    } catch (err: any) { alert(err.message); }
   };
 
   const handleClearCompleted = async () => {
     if (!confirm('Clear all completed tasks?')) return;
     try {
       await apiService.clearCompleted();
-      setTasks(prev => prev.filter(t => !t.isCompleted));
-      await updateStats();
     } catch (err: any) { alert(err.message); }
   };
 
@@ -143,7 +263,9 @@ const App: React.FC = () => {
             tasks={processedTasks}
             loading={loading}
             onToggle={handleToggleTask}
+            onToggleSubtask={handleToggleSubtask}
             onDelete={handleDeleteTask}
+            onEdit={handleEditTask}
             emptyMessage={
               filter === 'ALL' ? "Your list is empty. Add a task above to get started!" 
               : filter === 'ACTIVE' ? "You're all caught up! Great job." 
@@ -154,7 +276,7 @@ const App: React.FC = () => {
 
         <div className="mt-12 text-center opacity-60">
            <p className="text-[10px] text-slate-500 font-bold tracking-[0.2em] uppercase">
-             v2.1 • LocalStorage Database • Secure
+             v2.2 • LocalStorage Database • Secure
            </p>
         </div>
       </div>
@@ -163,3 +285,4 @@ const App: React.FC = () => {
 };
 
 export default App;
+    
\ No newline at end of file
diff --git a/src/client/services/apiService.ts b/src/client/services/apiService.ts
index c53d3aa..4a5afab 100644
--- a/src/client/services/apiService.ts
+++ b/src/client/services/apiService.ts
@@ -25,6 +25,12 @@ export const apiService = {
     return response.data;
   },
 
+  async updateTask(id: string, updates: UpdateTaskDTO): Promise<Task> {
+    const response = await TaskController.updateTask(id, updates);
+    if (!response.success || !response.data) throw new Error(response.error);
+    return response.data;
+  },
+
   async toggleTask(id: string, currentStatus: boolean): Promise<Task> {
     const payload: UpdateTaskDTO = { isCompleted: !currentStatus };
     const response = await TaskController.updateTask(id, payload);
@@ -32,6 +38,12 @@ export const apiService = {
     return response.data;
   },
 
+  async toggleSubtask(taskId: string, subtaskId: string): Promise<Task> {
+    const response = await TaskController.toggleSubtask(taskId, subtaskId);
+    if (!response.success || !response.data) throw new Error(response.error);
+    return response.data;
+  },
+
   async deleteTask(id: string): Promise<void> {
     const response = await TaskController.deleteTask(id);
     if (!response.success) throw new Error(response.error);
diff --git a/src/server/controllers/taskController.ts b/src/server/controllers/taskController.ts
index 4028278..1122278 100644
--- a/src/server/controllers/taskController.ts
+++ b/src/server/controllers/taskController.ts
@@ -27,7 +27,7 @@ export const TaskController = {
   async getTasks(): Promise<ApiResponse<Task[]>> {
     await delay(300); // Simulate network
     try {
-      const tasks = taskService.getAll();
+      const tasks = await taskService.getAll();
       return this._response(true, tasks);
     } catch (e) {
       return this._response(false, undefined, 'Internal Server Error', 500);
@@ -41,7 +41,7 @@ export const TaskController = {
     if (error) return this._response(false, undefined, error, 400);
 
     try {
-      const task = taskService.create(dto);
+      const task = await taskService.create(dto);
       return this._response(true, task, undefined, 201);
     } catch (e) {
       return this._response(false, undefined, 'Creation failed', 500);
@@ -55,7 +55,7 @@ export const TaskController = {
     if (error) return this._response(false, undefined, error, 400);
 
     try {
-      const task = taskService.update(id, dto);
+      const task = await taskService.update(id, dto);
       if (!task) return this._response(false, undefined, 'Task not found', 404);
       return this._response(true, task);
     } catch (e) {
@@ -63,10 +63,21 @@ export const TaskController = {
     }
   },
 
+  async toggleSubtask(taskId: string, subtaskId: string): Promise<ApiResponse<Task>> {
+    await delay(150);
+    try {
+      const task = await taskService.toggleSubtask(taskId, subtaskId);
+      if (!task) return this._response(false, undefined, 'Task or subtask not found', 404);
+      return this._response(true, task);
+    } catch (e) {
+      return this._response(false, undefined, 'Subtask toggle failed', 500);
+    }
+  },
+
   async deleteTask(id: string): Promise<ApiResponse<null>> {
     await delay(200);
     try {
-      const success = taskService.delete(id);
+      const success = await taskService.delete(id);
       if (!success) return this._response(false, undefined, 'Task not found', 404);
       return this._response(true, null, undefined, 204);
     } catch (e) {
@@ -77,7 +88,7 @@ export const TaskController = {
   async clearCompleted(): Promise<ApiResponse<{ count: number }>> {
     await delay(400);
     try {
-      const count = taskService.clearCompleted();
+      const count = await taskService.clearCompleted();
       return this._response(true, { count });
     } catch (e) {
       return this._response(false, undefined, 'Clear failed', 500);
@@ -85,9 +96,8 @@ export const TaskController = {
   },
 
   async getStats(): Promise<ApiResponse<TaskStats>> {
-    // Stats usually fast
     try {
-      const stats = taskService.getStats();
+      const stats = await taskService.getStats();
       return this._response(true, stats);
     } catch (e) {
       return this._response(false, undefined, 'Stats failed', 500);
diff --git a/src/server/db/jsonDatabase.ts b/src/server/db/jsonDatabase.ts
index 991a1a6..da18b2d 100644
--- a/src/server/db/jsonDatabase.ts
+++ b/src/server/db/jsonDatabase.ts
@@ -1,48 +1,293 @@
 
+
 // ============================================================================
 // DATABASE LAYER
 // Path: src/server/db/jsonDatabase.ts
 // ============================================================================
 
-import { Task, SystemLog } from '../../shared/types/task.types';
+import { Task, SystemLog, Priority } from '../../shared/types/task.types';
 import { DB_KEYS } from '../../shared/constants';
 
+// --- Interfaces ---
+
+interface Serializer {
+  encode<T>(data: T): string;
+  decode<T>(data: string): T;
+}
+
+// --- Compression Utilities (LZW) ---
+
+const LZW = {
+  compress(uncompressed: string): string {
+    let i, dictionary: any = {}, c, wc, w = "", result = [], dictSize = 256;
+    for (i = 0; i < 256; i += 1) dictionary[String.fromCharCode(i)] = i;
+    for (i = 0; i < uncompressed.length; i += 1) {
+      c = uncompressed.charAt(i);
+      wc = w + c;
+      if (dictionary.hasOwnProperty(wc)) {
+        w = wc;
+      } else {
+        result.push(dictionary[w]);
+        dictionary[wc] = dictSize++;
+        w = String(c);
+      }
+    }
+    if (w !== "") result.push(dictionary[w]);
+    return result.map(code => String.fromCharCode(code)).join("");
+  },
+
+  decompress(compressed: string): string {
+    let i, dictionary: any = [], w, result, k, entry = "", dictSize = 256;
+    for (i = 0; i < 256; i += 1) dictionary[i] = String.fromCharCode(i);
+    w = String.fromCharCode(compressed.charCodeAt(0));
+    result = w;
+    for (i = 1; i < compressed.length; i += 1) {
+      k = compressed.charCodeAt(i);
+      if (dictionary[k]) {
+        entry = dictionary[k];
+      } else {
+        if (k === dictSize) entry = w + w.charAt(0);
+        else return ""; // Corruption
+      }
+      result += entry;
+      dictionary[dictSize++] = w + entry.charAt(0);
+      w = entry;
+    }
+    return result;
+  }
+};
+
+// --- Serializer Implementation ---
+
+class AdvancedSerializer implements Serializer {
+  encode<T>(data: T): string {
+    const seen = new WeakSet();
+    const json = JSON.stringify(data, (key, value) => {
+      // 1. Circular Reference Detection
+      if (typeof value === "object" && value !== null) {
+        if (seen.has(value)) {
+          return "[Circular]";
+        }
+        seen.add(value);
+      }
+      return value;
+    });
+
+    // 3. Compression for large payloads (> 2KB)
+    if (json.length > 2048) {
+      return "BZ:" + LZW.compress(json);
+    }
+    return json;
+  }
+
+  decode<T>(data: string): T {
+    if (!data) return [] as any;
+    let jsonString = data;
+    
+    // Decompression
+    if (data.startsWith("BZ:")) {
+      jsonString = LZW.decompress(data.substring(3));
+    }
+
+    return JSON.parse(jsonString, (key, value) => {
+      // 4. Date Deserialization
+      // Simple heuristic: ISO 8601 date string detection
+      if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value)) {
+        const d = new Date(value);
+        if (!isNaN(d.getTime())) return d;
+      }
+      return value;
+    });
+  }
+}
+
+// --- Database Class ---
+
 class JsonDatabase {
+  private memoryStorage: Record<string, string> = {};
+  private serializer: Serializer = new AdvancedSerializer();
+  private useIndexedDB: boolean = false;
+  private idbName = 'SimplyDoneDB';
+  private idbStore = 'store';
+
+  constructor() {
+    this.init();
+  }
+
+  private init() {
+    // Detect if we should attempt IndexedDB (Browser only)
+    if (typeof window !== 'undefined' && 'indexedDB' in window) {
+      this.useIndexedDB = true;
+      // Init IDB
+      try {
+        const request = window.indexedDB.open(this.idbName, 1);
+        request.onupgradeneeded = (event: any) => {
+          const db = event.target.result;
+          if (!db.objectStoreNames.contains(this.idbStore)) {
+             db.createObjectStore(this.idbStore);
+          }
+        };
+      } catch (e) {
+        console.warn("IndexedDB access denied", e);
+        this.useIndexedDB = false;
+      }
+    }
+  }
+
+  // Check if we are running in a browser environment
+  private get isBrowser(): boolean {
+    return typeof window !== 'undefined' && typeof window.localStorage !== 'undefined';
+  }
+
+  // --- Low Level Storage Access ---
+
+  public setItem(key: string, value: string): void {
+     // Used for testing access directly to underlying storage
+     if (this.isBrowser) {
+         window.localStorage.setItem(key, value);
+     } else {
+         this.memoryStorage[key] = value;
+     }
+  }
+
+  private async getRaw(key: string): Promise<string | null> {
+    if (this.isBrowser) {
+      const marker = window.localStorage.getItem(key);
+      if (marker === "IDB_REF" && this.useIndexedDB) {
+        try {
+           return await this.getFromIDB(key);
+        } catch (e) {
+           console.error("IDB Read Error", e);
+           return null;
+        }
+      }
+      return marker;
+    }
+    return this.memoryStorage[key] || null;
+  }
+
+  private async setRaw(key: string, value: string): Promise<void> {
+    if (this.useIndexedDB && value.length > 5000) {
+      // Use IDB for larger datasets
+      try {
+        await this.setToIDB(key, value);
+        // Store a marker in LocalStorage
+        if (this.isBrowser) {
+             window.localStorage.setItem(key, "IDB_REF");
+        }
+        return;
+      } catch (e) {
+        console.warn("IDB Write failed, falling back to LocalStorage", e);
+      }
+    }
+
+    // Standard storage or fallback
+    if (this.isBrowser) {
+      try {
+        window.localStorage.setItem(key, value);
+      } catch (e) {
+        // Quota exceeded? Attempt IDB fallback if not already tried
+        if (this.useIndexedDB) {
+           await this.setToIDB(key, value);
+           window.localStorage.setItem(key, "IDB_REF");
+        }
+      }
+    } else {
+      this.memoryStorage[key] = value;
+    }
+  }
+
+  // --- IndexedDB Helpers ---
+
+  private getFromIDB(key: string): Promise<string | null> {
+    return new Promise((resolve, reject) => {
+      const request = window.indexedDB.open(this.idbName, 1);
+      request.onsuccess = (event: any) => {
+        const db = event.target.result;
+        const tx = db.transaction(this.idbStore, 'readonly');
+        const store = tx.objectStore(this.idbStore);
+        const getReq = store.get(key);
+        getReq.onsuccess = () => resolve(getReq.result || null);
+        getReq.onerror = () => reject(getReq.error);
+      };
+      request.onerror = () => reject(request.error);
+    });
+  }
+
+  private setToIDB(key: string, value: string): Promise<void> {
+    return new Promise((resolve, reject) => {
+      const request = window.indexedDB.open(this.idbName, 1);
+      request.onsuccess = (event: any) => {
+        const db = event.target.result;
+        const tx = db.transaction(this.idbStore, 'readwrite');
+        const store = tx.objectStore(this.idbStore);
+        const putReq = store.put(value, key);
+        putReq.onsuccess = () => resolve();
+        putReq.onerror = () => reject(putReq.error);
+      };
+      request.onerror = () => reject(request.error);
+    });
+  }
   
-  readTasks(): Task[] {
+  // --- Public API ---
+
+  async readTasks(): Promise<Task[]> {
     try {
-      const data = localStorage.getItem(DB_KEYS.TASKS);
-      return data ? JSON.parse(data) : [];
+      const raw = await this.getRaw(DB_KEYS.TASKS);
+      if (!raw) return [];
+      
+      const decoded = this.serializer.decode(raw);
+      return this.validateTasks(decoded);
     } catch (e) {
       console.error("[DB] Read Error", e);
       return [];
     }
   }
 
-  writeTasks(tasks: Task[]): void {
+  async writeTasks(tasks: Task[]): Promise<void> {
     try {
-      localStorage.setItem(DB_KEYS.TASKS, JSON.stringify(tasks));
+      const encoded = this.serializer.encode(tasks);
+      await this.setRaw(DB_KEYS.TASKS, encoded);
     } catch (e) {
       console.error("[DB] Write Error", e);
     }
   }
 
-  writeLog(log: SystemLog): void {
+  async writeLog(log: SystemLog): Promise<void> {
     try {
-      const logs = this.readLogs();
+      const logs = await this.readLogs();
       logs.push(log);
-      // Limit logs to prevent localStorage quotas
       if (logs.length > 200) logs.shift();
-      localStorage.setItem(DB_KEYS.LOGS, JSON.stringify(logs));
+      const encoded = this.serializer.encode(logs);
+      await this.setRaw(DB_KEYS.LOGS, encoded);
     } catch (e) {
       console.error("[DB] Log Error", e);
     }
   }
 
-  readLogs(): SystemLog[] {
-    const data = localStorage.getItem(DB_KEYS.LOGS);
-    return data ? JSON.parse(data) : [];
+  async readLogs(): Promise<SystemLog[]> {
+    try {
+      const raw = await this.getRaw(DB_KEYS.LOGS);
+      if (!raw) return [];
+      return this.serializer.decode(raw) as SystemLog[];
+    } catch (e) {
+       console.error("[DB] Log Read Error", e);
+       return [];
+    }
+  }
+
+  // 5. Task Type Validation
+  private validateTasks(data: any): Task[] {
+    if (!Array.isArray(data)) return [];
+    return data.filter((t: any) => {
+      return (
+        typeof t === 'object' && 
+        t !== null &&
+        typeof t.id === 'string' &&
+        typeof t.text === 'string'
+      );
+    });
   }
 }
 
-export const db = new JsonDatabase();
+export const db = new JsonDatabase();
\ No newline at end of file
diff --git a/src/server/services/taskService.ts b/src/server/services/taskService.ts
index 16d21d4..86f40e6 100644
--- a/src/server/services/taskService.ts
+++ b/src/server/services/taskService.ts
@@ -4,7 +4,7 @@
 // Path: src/server/services/taskService.ts
 // ============================================================================
 
-import { Task, CreateTaskDTO, UpdateTaskDTO, TaskStats, Priority, SystemLog } from '../../shared/types/task.types';
+import { Task, CreateTaskDTO, UpdateTaskDTO, TaskStats, Priority, SystemLog, TaskObserver, TaskEvent } from '../../shared/types/task.types';
 import { db } from '../db/jsonDatabase';
 
 // Internal Logger Service
@@ -14,7 +14,7 @@ const Logger = {
   error: (msg: string, ctx?: any) => log('ERROR', msg, ctx),
 };
 
-function log(level: 'INFO' | 'WARN' | 'ERROR', message: string, context?: any) {
+async function log(level: 'INFO' | 'WARN' | 'ERROR', message: string, context?: any) {
   const entry: SystemLog = {
     id: crypto.randomUUID(),
     level,
@@ -22,22 +22,37 @@ function log(level: 'INFO' | 'WARN' | 'ERROR', message: string, context?: any) {
     timestamp: Date.now(),
     context
   };
-  db.writeLog(entry);
+  await db.writeLog(entry);
   if (level === 'ERROR') console.error(`[SERVER] ${message}`, context);
 }
 
 class TaskService {
+  private observers: TaskObserver[] = [];
+
+  subscribe(observer: TaskObserver) {
+    this.observers.push(observer);
+  }
+
+  unsubscribe(observer: TaskObserver) {
+    this.observers = this.observers.filter(obs => obs !== observer);
+  }
+
+  private notify(type: TaskEvent['type'], payload: any) {
+    const event: TaskEvent = { type, payload, timestamp: Date.now() };
+    this.observers.forEach(obs => obs.update(event));
+  }
   
-  getAll(): Task[] {
-    return db.readTasks();
+  async getAll(): Promise<Task[]> {
+    return await db.readTasks();
   }
 
-  getById(id: string): Task | undefined {
-    return db.readTasks().find(t => t.id === id);
+  async getById(id: string): Promise<Task | undefined> {
+    const tasks = await db.readTasks();
+    return tasks.find(t => t.id === id);
   }
 
-  create(dto: CreateTaskDTO): Task {
-    const tasks = db.readTasks();
+  async create(dto: CreateTaskDTO): Promise<Task> {
+    const tasks = await db.readTasks();
     
     // Check for duplicate active tasks
     const isDuplicate = tasks.some(t => 
@@ -46,7 +61,7 @@ class TaskService {
     );
 
     if (isDuplicate) {
-      Logger.warn('Creating duplicate task', { text: dto.text });
+      await Logger.warn('Creating duplicate task', { text: dto.text });
     }
 
     const newTask: Task = {
@@ -55,26 +70,27 @@ class TaskService {
       description: dto.description?.trim(),
       priority: dto.priority,
       isCompleted: false,
+      subtasks: [],
       createdAt: Date.now(),
       updatedAt: Date.now(),
     };
 
     tasks.push(newTask);
-    db.writeTasks(tasks);
-    Logger.info('Task created', { id: newTask.id });
+    await db.writeTasks(tasks);
+    await Logger.info('Task created', { id: newTask.id });
     
+    this.notify('CREATE', { taskId: newTask.id });
     return newTask;
   }
 
-  update(id: string, dto: UpdateTaskDTO): Task | null {
-    const tasks = db.readTasks();
+  async update(id: string, dto: UpdateTaskDTO): Promise<Task | null> {
+    const tasks = await db.readTasks();
     const index = tasks.findIndex(t => t.id === id);
     
     if (index === -1) return null;
 
     const currentTask = tasks[index];
     
-    // Handle completion timestamp logic
     let completedAt = currentTask.completedAt;
     if (dto.isCompleted === true && !currentTask.isCompleted) {
       completedAt = Date.now();
@@ -90,38 +106,65 @@ class TaskService {
     };
 
     tasks[index] = updatedTask;
-    db.writeTasks(tasks);
-    Logger.info('Task updated', { id, updates: Object.keys(dto) });
-    
+    await db.writeTasks(tasks);
+    await Logger.info('Task updated', { id, updates: Object.keys(dto) });
+
+    this.notify('UPDATE', { taskId: id });
     return updatedTask;
   }
 
-  delete(id: string): boolean {
-    const tasks = db.readTasks();
+  async toggleSubtask(taskId: string, subtaskId: string): Promise<Task | null> {
+    const tasks = await db.readTasks();
+    const taskIndex = tasks.findIndex(t => t.id === taskId);
+    
+    if (taskIndex === -1) return null;
+    
+    const task = tasks[taskIndex];
+    if (!task.subtasks) task.subtasks = [];
+
+    const subtaskIndex = task.subtasks.findIndex(s => s.id === subtaskId);
+    if (subtaskIndex === -1) return null;
+
+    task.subtasks[subtaskIndex].isCompleted = !task.subtasks[subtaskIndex].isCompleted;
+    task.updatedAt = Date.now();
+
+    tasks[taskIndex] = task;
+    await db.writeTasks(tasks);
+    await Logger.info('Subtask toggled', { taskId, subtaskId });
+
+    this.notify('UPDATE', { taskId });
+    return task;
+  }
+
+  async delete(id: string): Promise<boolean> {
+    const tasks = await db.readTasks();
     const filtered = tasks.filter(t => t.id !== id);
     
     if (filtered.length === tasks.length) return false;
 
-    db.writeTasks(filtered);
-    Logger.info('Task deleted', { id });
+    await db.writeTasks(filtered);
+    await Logger.info('Task deleted', { id });
+    
+    this.notify('DELETE', { taskId: id });
     return true;
   }
 
-  clearCompleted(): number {
-    const tasks = db.readTasks();
+  async clearCompleted(): Promise<number> {
+    const tasks = await db.readTasks();
     const activeTasks = tasks.filter(t => !t.isCompleted);
     const countRemoved = tasks.length - activeTasks.length;
     
     if (countRemoved > 0) {
-      db.writeTasks(activeTasks);
-      Logger.info('Cleared completed tasks', { count: countRemoved });
+      await db.writeTasks(activeTasks);
+      await Logger.info('Cleared completed tasks', { count: countRemoved });
+      this.notify('DELETE', { count: countRemoved }); // Broad notification
     }
     
     return countRemoved;
   }
 
-  getStats(): TaskStats {
-    const tasks = db.readTasks();
+  async getStats(): Promise<TaskStats> {
+    const tasks = await db.readTasks();
     const total = tasks.length;
     const completed = tasks.filter(t => t.isCompleted).length;
     
diff --git a/src/shared/types/task.types.ts b/src/shared/types/task.types.ts
index 00b22be..519a66b 100644
--- a/src/shared/types/task.types.ts
+++ b/src/shared/types/task.types.ts
@@ -23,6 +23,15 @@ export enum SortOption {
   PRIORITY_ASC = 'PRIORITY_ASC',
 }
 
+/**
+ * Subtask item structure.
+ */
+export interface SubTask {
+  id: string;
+  text: string;
+  isCompleted: boolean;
+}
+
 /**
  * The core Task object.
  */
@@ -32,6 +41,7 @@ export interface Task {
   description?: string;
   isCompleted: boolean;
   priority: Priority;
+  subtasks: SubTask[];
   createdAt: number;
   updatedAt: number;
   completedAt?: number;
@@ -79,10 +89,11 @@ export interface UpdateTaskDTO {
   isCompleted?: boolean;
   priority?: Priority;
   description?: string;
+  subtasks?: SubTask[];
 }
 
 /**
- * Log entry for the backend logger.
+ * System Log entry structure used in server logs.
  */
 export interface SystemLog {
   id: string;
@@ -91,3 +102,19 @@ export interface SystemLog {
   timestamp: number;
   context?: any;
 }
+
+/**
+ * Event payload for TaskObserver
+ */
+export interface TaskEvent {
+  type: 'CREATE' | 'UPDATE' | 'DELETE';
+  payload: any;
+  timestamp: number;
+}
+
+/**
+ * Observer interface for task changes
+ */
+export interface TaskObserver {
+  update(event: TaskEvent): void;
+}
